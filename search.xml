<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于promise</title>
    <url>/2020/08/19/JS%E4%B9%8Bpromise/</url>
    <content><![CDATA[<h1 id="promise实现"><a href="#promise实现" class="headerlink" title="promise实现"></a>promise实现</h1><p>以下为手写promise，实现的比较粗略<br>promise作为构造函数实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>promise的实现<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// let a = new Promise((resolve, reject) =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(123);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     setTimeout(function () &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         resolve('hhh')</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#125;, 0)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// a.then(res =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(1233);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(res)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;, rej =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(rej)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// Promise.all([1,2,3]).then(val =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(val)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// Promise.race([1,2,3]).then(val =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     console.log(val)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'----------------------'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">promise</span><span class="params">(executor)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        self.status = <span class="string">'pending'</span>;</span></span><br><span class="line"><span class="actionscript">        self.data = <span class="literal">null</span>;</span></span><br><span class="line">        self.callbacks = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (self.status !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            self.status = <span class="string">'resolved'</span>;</span></span><br><span class="line">            self.data = data;</span><br><span class="line">            if (self.callbacks.onResolved) &#123;</span><br><span class="line">                self.callbacks.onResolved(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (self.status !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            self.status = <span class="string">'rejected'</span>;</span></span><br><span class="line">            self.data = data;</span><br><span class="line">            if (self.callbacks.onRejected) &#123;</span><br><span class="line">                self.callbacks.onRejected(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    promise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onResolved, onRejected)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value;</span></span><br><span class="line"><span class="javascript">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span></span><br><span class="line"><span class="javascript">            queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">                handle(onResolved)</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span></span><br><span class="line"><span class="javascript">            queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">                handle(onRejected)</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span></span><br><span class="line">            self.callbacks = &#123;</span><br><span class="line"><span class="javascript">                onResolved: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">                        handle(onResolved)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                onRejected: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">                        handle(onRejected)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(callback)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line">                resolve(callback(self.data))</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    promise.resolve = <span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></span><br><span class="line">            resolve(val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    promise.race = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                promise.resolve(item).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span></span><br><span class="line">                    resolve(val)</span><br><span class="line">                &#125;, val =&gt; &#123;</span><br><span class="line">                    reject(val)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    promise.all = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> results = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> num = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> total = args.length</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            args.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                promise.resolve(item).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span></span><br><span class="line">                    results[index] = val;</span><br><span class="line">                    num++;</span><br><span class="line">                    if (num === total) &#123;</span><br><span class="line">                        resolve(results)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, val =&gt; &#123;</span><br><span class="line">                    reject(val)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> b = <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">123</span>)</span></span><br><span class="line"><span class="actionscript">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            resolve(<span class="string">'hhh'</span>)</span></span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    b.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">222</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    promise.race([<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>, <span class="string">'e'</span>]).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    promise.all([<span class="string">'a'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>]).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(val)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/Sunny-lucking/howToBuildMyPromise/blob/master/Promise_07%E5%AE%9E%E7%8E%B0Promise.race%E6%96%B9%E6%B3%95.js" target="_blank" rel="noopener">参考实现方式</a></p>
<p><a href="https://github.com/Yangfan2016/learn-translate/blob/master/1-Promises-A%2B_zh.md" target="_blank" rel="noopener">promise A+ 规范</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NDM5MDg1Mw==&mid=2247484225&idx=1&sn=b1d26191a41b9a3961f6798d1218fd79&chksm=fe00b96bc977307d2eab27dbd25bf6d27194d7fcdd9d9515822639b0206ad6ca1f946a0de7a9&token=1408690735&lang=zh_CN#rd" target="_blank" rel="noopener">promise面试题</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-ES6之箭头函数</title>
    <url>/2020/10/12/JS-ES6%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>箭头函数就是形如 <code>() =&gt; {}</code> 形式。</p>
<h1 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h1><ol>
<li>箭头函数没有自己的this，其this指向定义时父级。也就是说其this指向永远不会改变。</li>
<li>箭头函数没有自己的arguments。</li>
<li>箭头函数不能作为构造函数使用。因为没有自己的this指向，所以使用new时还会报错</li>
<li>箭头函数没有原型。</li>
<li>不能使用yeild关键字</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>es6</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>JS处理数据生成Excel表格</title>
    <url>/2020/04/23/JS%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90Excel%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="JS原生生成表格"><a href="#JS原生生成表格" class="headerlink" title="JS原生生成表格"></a>JS原生生成表格</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toExcel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  列标题，逗号隔开，每一个逗号就是隔开一个单元格</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">`标题1, 标题2, 标题3, 标题4\n`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  增加\t为了不让表格显示科学计数法或者其他格式</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">`内容1,内容2,内容2,内容4\t,\n内容4, 内容5,内容6,内容7\t,\n内容4,`</span></span><br><span class="line">    str += data</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  encodeURIComponent解决中文乱码</span></span><br><span class="line">    <span class="keyword">let</span> uri = <span class="string">'data:text/csv;charset=utf-8,\ufeff'</span> + <span class="built_in">encodeURIComponent</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.location.href = uri</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //  通过创建a标签实现</span></span><br><span class="line">    <span class="comment">// let link = document.createElement('a');</span></span><br><span class="line">    <span class="comment">// link.href = uri;</span></span><br><span class="line">    <span class="comment">// link.download = '测试.csv';</span></span><br><span class="line">    <span class="comment">// document.body.appendChild(link);</span></span><br><span class="line">    <span class="comment">// link.click();</span></span><br><span class="line">    <span class="comment">// document.body.removeChild(link);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式简单，但是有一些弊端如：<br>单元格之间用逗号分隔容易造成乱码，可以通过 .replace(/,/g, ‘，’) 替换成中文逗号，关键字\t\n也会造成一些问题需要解决，但能够快速生成表格解决燃眉之急</p>
<h2 id="使用工具生成"><a href="#使用工具生成" class="headerlink" title="使用工具生成"></a>使用工具生成</h2><ul>
<li>jQuery内有类似函数生成表格</li>
<li>SheetJS 生成表格</li>
</ul>
<p>主要介绍SheetJS 生成表格方法。 <a href="https://sheetjs.com/" target="_blank" rel="noopener">sheetjs官网</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  npm install xlsx 安装工具</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlsx <span class="keyword">from</span> <span class="string">'xlsx'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toExcel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  文件名称</span></span><br><span class="line">    <span class="keyword">let</span> filename = <span class="string">'测试.xlsx'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  数据需要转化成二维数组</span></span><br><span class="line">    <span class="keyword">let</span> data = [[<span class="string">'表头1'</span>, <span class="string">'表头2'</span>, <span class="string">'表头3'</span>], [<span class="string">'数据1'</span>, <span class="string">'数据2'</span>, <span class="string">'数据3'</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Excel第一个sheet的名称 </span></span><br><span class="line">    <span class="keyword">let</span> ws_name = <span class="string">"Sheet1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建工作薄对象</span></span><br><span class="line">    <span class="keyword">let</span> wb = xlsx.utils.book_new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  向工作簿追加一个工作表</span></span><br><span class="line">    <span class="keyword">let</span> ws = xlsx.utils.aoa_to_sheet(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  添加数据</span></span><br><span class="line">    xlsx.utils.book_append_sheet(wb, ws, ws_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  导出Excel</span></span><br><span class="line">    xlsx.writeFile(wb, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之call,apply,bind</title>
    <url>/2020/06/05/JS%E4%B9%8Bcall-apply-bind/</url>
    <content><![CDATA[<h3 id="简易理解"><a href="#简易理解" class="headerlink" title="简易理解"></a>简易理解</h3><p>猫吃鱼，狗吃肉，奥特曼打小怪兽。</p>
<p>有天狗想吃鱼了</p>
<p>猫.吃鱼.call(狗，鱼)</p>
<p>狗就吃到鱼了</p>
<p>猫成精了，想打怪兽</p>
<p>奥特曼.打小怪兽.call(猫，小怪兽)</p>
<p>或者 马云.赚钱.call(我)</p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this的指向在定义时是确定不了的，只有在执行时才会确定，指向调用它的那个函数。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>实现思路：</p>
<ol>
<li>将方法绑定在被改变的对象下</li>
<li>调用函数</li>
<li>删除对象下的函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="string">'chjssg'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param1, param2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param1, param2)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj, <span class="string">'aaa'</span>, <span class="string">'bbb'</span>) <span class="comment">//    chjssg</span></span><br><span class="line"></span><br><span class="line">foo()   <span class="comment">// 浏览器环境下是window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------自实现call函数------------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context = context || window || &#123;&#125;</span></span><br><span class="line">    context = context || &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    arr.shift()</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    context.fn(...arr);</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call2(obj, <span class="string">'param1'</span>, <span class="string">'param2'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooo</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name,sex)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fooo.apply(person, [<span class="string">"chj"</span>, <span class="string">"man"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------自实现apply函数------------------'</span>)</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context = context || window || &#123;&#125;</span></span><br><span class="line">    context = context || &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    context.fn(...arr);</span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fooo.apply2(person, [<span class="string">'chj'</span>, <span class="string">'chinese-man'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind() 方法会创建一个新函数。当这个新函数被调用时，<br>bind() 的第一个参数将作为它运行时的 this，<br>之后的一序列参数将会在传递的实参前传入作为它的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foooo</span>(<span class="params">param1, param2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param1, param2)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    value: <span class="string">'chjssgssg'</span></span><br><span class="line">&#125;</span><br><span class="line">foooo.prototype.aaa = <span class="string">'myfriend'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foooo.bind(obj1, <span class="string">'wewe'</span>);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">'aaa'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-----'</span>+fn.aaa)</span><br><span class="line"><span class="keyword">var</span> newFn = <span class="keyword">new</span> fn(<span class="string">'aaa'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newFn.aaa)</span><br><span class="line"><span class="comment">// console.log(newFn)</span></span><br><span class="line"><span class="comment">// newFn('aaa', 'bbb')</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------自实现bind函数------------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> paramArr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    paramArr.shift()</span><br><span class="line">    <span class="comment">// if(paramArr.length==0) paramArr = null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> param = [...paramArr ,...Array.from(<span class="built_in">arguments</span>)]</span><br><span class="line">        <span class="built_in">console</span>.log(param)</span><br><span class="line">        context = context || &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span>  self.call(context, ...param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = foooo.bind2(obj1);</span><br><span class="line"><span class="keyword">var</span> result = fn1(<span class="string">'chj'</span>, <span class="string">'chj'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>this</tag>
        <tag>bind</tag>
        <tag>JS基础</tag>
        <tag>手撕bind</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步解决方案</title>
    <url>/2020/05/07/JS%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>所谓异步，就是在函数执行后不能马上得到结果就是异步函数，常见的比如ajax.<br>JavaScript针对异步提供了以下六种解决方式</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数是一个函数作为参数传递给另一个函数的函数，然后在需要调用的时候调用这个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = a + b;</span><br><span class="line">    callback(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, print) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>回调函数的优点是简单、容易理解。缺点不利于代码阅读和维护，高耦合，流程结构混乱，容易造成回调地狱。不能try catch捕获错误，不能直接return</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>异步编程</li>
<li>事件监听</li>
<li>配合setTimeout、setInterval</li>
</ul>
<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>这种思路不取决于代码执行顺序，取决于事件是否触发。比如点击事件等</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>可以绑定多个事件，每个事件可以指定多个回调函数<br>缺点：程序变成事件驱动型，运行流程不清晰</p>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>（与事件监听类似）</p>
<h1 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ <a href="https://promisesaplus.com" target="_blank" rel="noopener">规范</a></h1><p>promise是异步解决方案。ES6将其写进语言标准并提供了promise对象。<br>我们可以从promise对象内获取异步操作的结果，并使用相应回调函数处理结果</p>
<h2 id="使用-详细语法"><a href="#使用-详细语法" class="headerlink" title="使用 详细语法"></a>使用 <a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">详细语法</a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">f1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  resolve</span></span><br></pre></td></tr></table></figure>
<p>通过 .then() 方法处理状态变化的回调函数</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>状态不受外部影响，也就是说只有内部的结果能决定其状态</li>
<li>状态一经改变就不会在改变。只能从 pending =&gt; fulfilled 或 pending =&gt; rejected</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h1 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h1><p>generator函数首先可以理解成一个状态机，封装了多个内部状态。<br>执行generator函数时会返回一个遍历器对象，可以遍历函数内部的不同状态</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>yield表示暂停标志，next方法可启动，每次返回的是yield后面表达式的结果。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>async/await通过generator和promise的实现，是generator函数的语法糖。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> foo()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> foo()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF();</span><br><span class="line"></span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(val); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现其实并不难，重要的是理解async函数的行为，返回一个promise函数，要想保持完全同步，await后面要接promise</p>
<h3 id="await都做了什么"><a href="#await都做了什么" class="headerlink" title="await都做了什么"></a>await都做了什么</h3><p>首先：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'async2'</span>)&#125;</span><br><span class="line"><span class="comment">//  等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题关键就出在这个 RESOLVE 上</p>
<ul>
<li>RESOLVE(p)接近于Promise.resolve(p)，不过有微妙而重要的区别：p 如果本身已经是 Promise 实例，Promise.resolve 会直接返回 p 而不是产生一个新 promise；</li>
<li>如果RESOLVE(p)严格按照标准，应该产生一个新的 promise，尽管该 promise 确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve 过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了<br><del>await规范不断更新，这一块我还没有十分清楚</del></li>
</ul>
<p>所以上述的 async1 函数我们可以进一步转换一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(async2())</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>await后面接普通函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> test2()</span><br><span class="line">    <span class="keyword">await</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'one'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'three'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'two'</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// two three one</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  其中foo函数等价于</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> test2()</span><br><span class="line">    <span class="comment">// return new Promise(resolve =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     resolve(setTimeout(function() &#123;console.log('one')&#125;, 1000))</span></span><br><span class="line">    <span class="comment">// &#125;).then(function () &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('three')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">//  //上面这种方式和下面的一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'one'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'three'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await后面接promise对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> test()</span><br><span class="line">    <span class="keyword">await</span> test2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'three'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'one'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'two'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// one two three</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  其中foo函数等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> test()</span><br><span class="line">    <span class="comment">// await test2()</span></span><br><span class="line">    <span class="comment">// console.log('three')</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(test2()) </span><br><span class="line">        <span class="comment">//  // resolve(test2()) 等价于</span></span><br><span class="line">        <span class="comment">/* resolve(new Promise((resolve) =&gt; &#123;</span></span><br><span class="line"><span class="comment">            setTimeout(function() &#123;</span></span><br><span class="line"><span class="comment">                console.log('two')</span></span><br><span class="line"><span class="comment">                resolve();</span></span><br><span class="line"><span class="comment">            &#125;, 1000);</span></span><br><span class="line"><span class="comment">        &#125;))</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'three'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  这是因为async函数返回一个promise对象，</span></span><br><span class="line"><span class="comment">//  通过reslove进行下一步操作，将reslove放在setTimeout里，</span></span><br><span class="line"><span class="comment">//  自然需要等待setTimeout执行完才能输出 'three'</span></span><br></pre></td></tr></table></figure>
<h1 id="简单面试题-判断执行顺序"><a href="#简单面试题-判断执行顺序" class="headerlink" title="简单面试题-判断执行顺序"></a>简单面试题-判断执行顺序</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"settimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// settimeout</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>JS异步</tag>
        <tag>async/await</tag>
        <tag>generator</tag>
      </tags>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/2020/06/02/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<p>JS的模块通常就是指一个文件，每一个文件当做一个独立的作用域，对外暴露变量或者函数。<br>JS模块化有几种方案分别是 CommonJS，AMD，CMD，UMD，ESModule</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>适用于服务端<br>最大的特点就是<strong>同步加载</strong><br>流程：<br>路径解析–&gt;文件加载–&gt;模块封装–&gt;编译执行–&gt;缓存</p>
<p>在浏览器端使用commonJS具体实现：</p>
<ol>
<li>先使用require.register注册文件路径和对应方法之间的映射关系保存在require.modules中</li>
<li>再使用require方法，通过传入的路径去require.modules中取出对应的方法</li>
<li>使用require获取方法的同时，会触发依赖模块中的require方法，这样就实现了模块的加载</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mod = <span class="built_in">require</span>.modules[path];</span><br><span class="line">    mod.exports = &#123;&#125;;</span><br><span class="line">    mod.call(<span class="built_in">window</span>, <span class="built_in">require</span>, mod, mod.exports);</span><br><span class="line">    <span class="keyword">return</span> mod.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.register = <span class="function"><span class="keyword">function</span> (<span class="params">path, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步加载</span></span><br><span class="line">    <span class="built_in">require</span>.modules[path] = fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1. 异步加载的逻辑也不复杂，在同步加载的基础上增加require.ensure方法，预先在modules对象上挂在onload方法</span></span><br><span class="line"><span class="comment">//  2. 修改require.register方法，增加异步模块注册逻辑，在异步模块注册完成后触发onload，以达到模块异步加载的需求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  异步的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mod = <span class="built_in">require</span>.modules[path].method;</span><br><span class="line">    mod.exports = &#123;&#125;;</span><br><span class="line">    mod.call(<span class="built_in">window</span>, <span class="built_in">require</span>, mod, mod.exports);</span><br><span class="line">    <span class="keyword">return</span> mod.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.register = <span class="function"><span class="keyword">function</span> (<span class="params">path, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步加载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">require</span>.modules[path] &amp;&amp; <span class="built_in">require</span>.modules[path].status === <span class="string">'loading'</span>) &#123;</span><br><span class="line">        <span class="comment">// 异步加载成功</span></span><br><span class="line">        <span class="built_in">require</span>.modules[path].status = <span class="string">'loaded'</span></span><br><span class="line">        <span class="built_in">require</span>.modules[path].method = fn;</span><br><span class="line">        <span class="built_in">require</span>.modules[path].onload(<span class="built_in">require</span>(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>.modules[path] = &#123;</span><br><span class="line">            moduleName: path, <span class="comment">// 模块Id</span></span><br><span class="line">            status: <span class="string">'loaded'</span>,</span><br><span class="line">            onload: <span class="literal">null</span>,</span><br><span class="line">            method: fn</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure = <span class="function"><span class="keyword">function</span> (<span class="params">path, cb</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>.modules[path] = &#123;</span><br><span class="line">        moduleName: path, <span class="comment">// 模块Id</span></span><br><span class="line">        status: <span class="string">'loading'</span>,</span><br><span class="line">        onload: cb,</span><br><span class="line">        method: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.querySelector(<span class="string">'head'</span>)</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.src = path;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        head.appendChild(script);</span><br><span class="line">    &#125;,<span class="number">5000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 规范加载模块是异步的，并允许函数回调，不必等到所有模块都加载完成，后续操作可以正常执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  规范 API</span></span><br><span class="line">define(id?, dependencies?, factory);</span><br><span class="line">define.amd = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无依赖的模块</span></span><br><span class="line">define(&#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">"./a.js"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alpha</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        verb: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h3><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD中，模块作为依赖且被引用时才会初始化，否则只会加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.test();</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="SeaJS"><a href="#SeaJS" class="headerlink" title="SeaJS"></a>SeaJS</h3><h2 id="AMD-CMD区别"><a href="#AMD-CMD区别" class="headerlink" title="AMD,CMD区别"></a>AMD,CMD区别</h2><ol>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块并加载</li>
<li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li>
</ol>
<h2 id="UMD兼容写法"><a href="#UMD兼容写法" class="headerlink" title="UMD兼容写法"></a>UMD兼容写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="comment">// CommonJS、CMD规范检查</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD规范检查</span></span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器注册全局对象</span></span><br><span class="line">        global.A = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        say: say</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    A.say(); /</span><span class="regexp">/ hello world</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line">A.say();</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>commonJS与ES6module区别</p>
<ol>
<li>CommonJS是运行时加载，ES6时编译时输出接口<br>commonJS加载的是一个对象，该对象在脚本运行完才会产生，es6模块不是模块，，他的对外接口只是一种静态定义，在代码解析执行就会生成。<br>因此es6有两个特点，一是import会被提前到文件顶部，exports会有变量提升的效果</li>
<li>CommonJS是值的拷贝，ES6是值的引用</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/38382637" target="_blank" rel="noopener">commonJS源码解析</a><br><a href="https://juejin.im/post/5d9feafdf265da5b794f1d89" target="_blank" rel="noopener">参考文章</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则总结</title>
    <url>/2020/06/19/JS%E6%AD%A3%E5%88%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>如何定义一个正则<br>JS 中使用非常方便</p>
<ol>
<li>直接量：<code>let reg = /s$/</code></li>
<li>构造函数：<code>let reg = new RegExp(&#39;s$&#39;);</code></li>
</ol>
<p>属性：</p>
<ol>
<li>global是一个只读的布尔值，说明这个正则表达式是否带有修饰符g</li>
<li>ignoreCase是一个只读的布尔值，说明正则表达式是否带有修饰符i</li>
<li>multiline只读布尔值，是否带有m</li>
</ol>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>介绍如何构建一个正则表达式</p>
<h3 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h3><p>支持非字母的匹配，通过反斜线进行转义</p>
<p><img src="/images/reg/1.png" alt="直接量字符" title="直接量字符"></p>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>一个字符类可以匹配它所包含的任意字符</p>
<p><img src="/images/reg/2.png" alt="字符类" title="字符类"></p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置<br><img src="/images/reg/3.png" alt="重复" title="重复"><br>非贪婪的重复：只需在待匹配的字符后跟随一个问号</p>
<h3 id="选择、分组、引用"><a href="#选择、分组、引用" class="headerlink" title="选择、分组、引用"></a>选择、分组、引用</h3><p><img src="/images/reg/4.png" alt="选择、分组、引用" title="选择、分组、引用"><br>(）作用：</p>
<ol>
<li>把单独的项组合成子表达式</li>
<li>在完整的模式中定义子模式，可以从目标中抽出和圆括号中的子模式相匹配的部分</li>
<li>允许在同一正则表达式的后部引用前面的子表达式</li>
</ol>
<h3 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h3><p><img src="/images/reg/5.png" alt="指定匹配位置" title="指定匹配位置"></p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符是放在//符号之外的</p>
<p><img src="/images/reg/6.png" alt="修饰符" title="修饰符"></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>介绍支持正则的方法</p>
<h3 id="字符串方法应用正则"><a href="#字符串方法应用正则" class="headerlink" title="字符串方法应用正则"></a>字符串方法应用正则</h3><h4 id="search（）"><a href="#search（）" class="headerlink" title="search（）"></a>search（）</h4><p>不支持全局检索，忽略正则表达式参数中的修饰符g</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"chj chj chj!"</span>; </span><br><span class="line"><span class="keyword">let</span> n = str.search(<span class="regexp">/chj/i</span>); <span class="comment">// n = 0</span></span><br></pre></td></tr></table></figure>

<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>replace方法不改变原来的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"chj Chj chj!"</span>; </span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/chj/ig</span>;</span><br><span class="line"><span class="keyword">let</span> new_str = str.replace(reg, <span class="string">'chjssg'</span>); <span class="comment">// "chjssg chjssg chjssg!"</span></span><br></pre></td></tr></table></figure>
<p>替换的可以是字符串，也可以是函数（也就是上面’chjssg’这个位置）。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。<br><img src="/images/reg/7.jpg" alt="$含义" title="$含义"></p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Jeff, Chen"</span>;</span><br><span class="line"><span class="keyword">let</span> new_name = name.replace(<span class="regexp">/(\w+)\s*, \s*(\w+)/</span>, <span class="string">"$2 $1"</span>);</span><br><span class="line"><span class="comment">//  Chen, Jeff</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  函数的例子</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'aaa bbb ccc'</span>;</span><br><span class="line"><span class="keyword">let</span> uw = name.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + word.substring(<span class="number">1</span>);&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// "Aaa Bbb Ccc"</span></span><br></pre></td></tr></table></figure>
<h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有全局匹配字符g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'chj chj CHJ'</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/chj/g</span>;</span><br><span class="line">str.match(reg) <span class="comment">// ["chj", "chj"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有有全局匹配字符g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'chj chj CHJ'</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/chj/</span>;</span><br><span class="line">str.match(reg) <span class="comment">// ["chj", index: 0, input: "chj chj CHJ", groups: undefined]</span></span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"姓名+性别+年龄"</span></span><br><span class="line"><span class="keyword">let</span> arr = str.split(<span class="regexp">/[,+]/</span>) <span class="comment">// ["姓名", "性别", "年龄"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg2</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'chjssg is a handsome boy'</span></span><br><span class="line"><span class="keyword">let</span> words = str.split(<span class="regexp">/\s+/</span>) <span class="comment">// ["chjssg", "is", "a", "handsome", "boy"]</span></span><br></pre></td></tr></table></figure>

<h3 id="正则对象上方法"><a href="#正则对象上方法" class="headerlink" title="正则对象上方法"></a>正则对象上方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec() 方法用于检索字符串中的正则表达式的匹配。<br>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/chj/</span>;</span><br><span class="line">reg.exec(<span class="string">"The handsome boy -chj, chj is shuaiqi "</span>); </span><br><span class="line"><span class="comment">// ["chj", index: 18, input: "The handsome boy -chj, chj is shuaiqi ", groups: undefined]</span></span><br></pre></td></tr></table></figure>

<h4 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h4><p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/chj/</span>;</span><br><span class="line">reg.test(<span class="string">"The handsome boy -chj "</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="一些正则例子"><a href="#一些正则例子" class="headerlink" title="一些正则例子"></a>一些正则例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  匹配url: http(s)://...</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(http:\/\/|https:\/\/)((\w|=|\?|\.|\/|&amp;|-)+)/g</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JS循环引用问题</title>
    <url>/2020/06/04/JS%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="import-和-require"><a href="#import-和-require" class="headerlink" title="import 和 require"></a>import 和 require</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>是ES6出的模块化方案，其目的是尽量静态化，所以ES6的模块化是编译时解析</p>
<h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p>是运行时解析，是一个值得拷贝，是属于浅拷贝<br>当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，commonjs模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<p>循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<h3 id="问题如此："><a href="#问题如此：" class="headerlink" title="问题如此："></a>问题如此：</h3><p>写nodejs时碰到令人头疼的require循环引用问题<br><a href="https://github.com/nodejs/node/issues/2923" target="_blank" rel="noopener">GitHub issue链接</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  a.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; bbb &#125; = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num)</span><br><span class="line">        bbb(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; aaa &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  b.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; aaa &#125; = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        num = num / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">        aaa(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bbb'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; bbb &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  index.js</span></span><br><span class="line"><span class="keyword">var</span> &#123;aaa&#125; = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">aaa(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>运行后报错如下<br><img src="/images/JS/JS%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt="报错详情" title="报错详情"><br>这是因为node的require语法处理的结果，如果是对象之间循环引用的话会变为空对象。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>将a.js的<code>const { bbb } = require(&#39;./b&#39;)</code>写在module.exports下面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num)</span><br><span class="line">        bbb(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; aaa &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; bbb &#125; = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以运行，因为在加载b文件前先导出了aaa函数，能够运行。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS混淆</title>
    <url>/2020/07/11/JS%E6%B7%B7%E6%B7%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总结一下关于JS混淆内容。</p>
<p><strong><em>为什么是混淆而不是加密？</em></strong><br>没有办法真正给js加密，毕竟最终js要被浏览器的JS引擎解析，这个解析的过程没办法隐蔽起来，所以JS加密的方向只有混淆而已<br><strong><em>混淆的作用？</em></strong></p>
<ol>
<li>商业利益保护，防抄袭</li>
<li>让代码尽量的不被分析：如锤子手机翻车事件</li>
<li>防止代码被篡改</li>
<li>代码不可读是唯一目的</li>
</ol>
<h1 id="混淆方法"><a href="#混淆方法" class="headerlink" title="混淆方法"></a>混淆方法</h1><p>混淆方法多种多样可以使用base62，源码AST分析修改，借助webAssembly</p>
<h2 id="base62编码"><a href="#base62编码" class="headerlink" title="base62编码"></a>base62编码</h2><p>Base62编码：这类混淆的思路在于将需要执行的代码进行一次编码，在执行的时候还原出浏览器可执行的合法的脚本，然后执行。看上去和可执行文件的加壳有那么点类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源代码</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//混淆后</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,d</span>)</span>&#123;e=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span>(c&lt;a?<span class="string">""</span>:e(<span class="built_in">parseInt</span>(c/a)))+((c=c%a)&gt;<span class="number">35</span>?<span class="built_in">String</span>.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)d[e(c)]=k[c]||e(c);k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> d[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>;&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p;&#125;(<span class="string">'0 2=1;'</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'var||a'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</span><br></pre></td></tr></table></figure>
<p>其最明显的特征是生成的代码以 eval(function(p,a,c,k,e,r)) 开头。</p>
<p>无论代码如何进行变形，其最终都要调用一次 eval 等函数。解密的方法不需要对其算法做任何分析，只需要简单地找到这个最终的调用，改为 console.log 或者其他方式，将程序解码后的结果按照字符串输出即可。</p>
<h2 id="字符串拼接等"><a href="#字符串拼接等" class="headerlink" title="字符串拼接等"></a>字符串拼接等</h2><ol>
<li>访问一个对象的成员有两种方法——点运算符和下标运算符。调用 window 的 eval 方法，既可以写成 window.eval()，也可以 window[‘eval’]；</li>
<li>为了让代码更变态一些，混淆器选用第二种写法，然后再在字符串字面量上做文章。先把字符串拆成几个部分：’e’ + ‘v’ + ‘al’；</li>
<li>再利用一个数字进制转换的技巧：14..toString(15) + 31..toString(32) + 0xf1.toString(22)；</li>
<li>将数字也展开：(0b1110).toString(4&lt;&lt;2) + (‘ ‘.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)；</li>
<li>效果：window<a href="'alert(1)'">(2*7).toString(4&lt;&lt;2) + (‘ ‘.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)</a></li>
</ol>
<h2 id="AST方式"><a href="#AST方式" class="headerlink" title="AST方式"></a>AST方式</h2><p>其实也可以通过正则替换实现，单比较容易反混淆。</p>
<p>通过语法树替换实现的混淆器：<br><img src="/images/JS/JS%E6%B7%B7%E6%B7%86.jpg" alt="JS混淆" title="混淆"><br>在源代码的解释和编译过程中，语法分析器创建出抽象语法树，它是源代码的抽象语法结构的树状表现形式，树上的每个节点都表示源代码中的一种结构。一颗抽象语法树展示一个程序的完整语法结构，并不会包含真实语法中出现的每个细节。<br><img src="/images/JS/JS%E6%B7%B7%E6%B7%86-AST.png" alt="JS混淆" title="混淆"></p>
<p>AST的其他工具<br>escope Javascript 作用域分析工具<br>esutil 辅助函数库，检查语法树节点是否满足某些条件<br>estraverse 语法树遍历辅助库，接口有一点类似 SAX 方式解析 XML<br>esrecurse 另一个语法树遍历工具，使用递归<br>esquery 使用 css 选择器的语法从语法树中提取符合条件的节点<br>escodegen 与 esprima 功能互逆，将语法树还原为代码</p>
<h3 id="混淆规则设计"><a href="#混淆规则设计" class="headerlink" title="混淆规则设计"></a>混淆规则设计</h3><p>混淆变量和函数名：将变量、函数名称通过hash算法混淆，不可逆<br>字符串阵列化：将字符串进行阵列化放置，使赋值、读写等操作不易被查觉。并将字符串进行混淆，使之不出现明文字符串、常量<br>混淆控制流：通过组合拆分的方式，更改代码原有的分枝逻辑，打乱代码原有的相关系，使代码变的不可理解<br>运算符混淆：将点运算符替换为字符串下标形式，然后对字符串进行混淆。<br>字符串二次加密：对混淆后的字符串进行二次加密，使破解更加困难。<br>压缩代码：去除回车换行、空格。减小代码体积的同时使代码难以正常阅读。<br>反调试：使浏览器调试工具不可用，剔除命令行调试语句，使不打印出调试信息。<br>域名锁定：使代码只能在指定的域名（含子域名）下运行，复制到其它任何地方、任何网站都无法运行。 可以防止产品被复制盗用。</p>
<h3 id="已有混淆工具"><a href="#已有混淆工具" class="headerlink" title="已有混淆工具"></a>已有混淆工具</h3><p>UglifyJS、javascript-obfuscator<br>国外商业软件：Jscrambler<br>国内商业软件：Jshaman</p>
<h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>C / C++ 编译成 JS 有两个最大的困难。</p>
<ol>
<li>C / C++ 是静态类型语言，而 JS 是动态类型语言。</li>
<li>C / C++ 是手动内存管理，而 JS 依靠垃圾回收机制。<br>asm.js 就是为了解决这两个问题而设计的：它的变量一律都是静态类型，并且取消垃圾回收机制。除了这两点，它与 JavaScript 并无差异，也就是说，asm.js 是 JavaScript 的一个严格的子集，只能使用后者的一部分语法。</li>
</ol>
<p>Js引擎运行asm.js与运行普通Js代码不一样，跳过语法分析，直接转为汇编语言，浏览器还会调用webGL通过GPU执行asm.js。这使得asm.js在浏览器运行速度更快</p>
<p>webAssembly 的前身是asm.js 。c/c++代码通过Emscripten编译器编译成asm.js文件。<br>而webAssembly与asm原理一致，但是转出来的代码不一样是二进制.wasm文件，asm.js是文本格式。 webAssembly使得运行速度更快。</p>
<p>谷歌、苹果、微软和Mozilla的工程师正合力创建WebAssembly（又名wasm），这是能够运用在未来浏览器中承诺可带来20倍更快性能的字节码（bytecode）。WebAssembly项目创造全新的字节码（一种机器可读的指令集，能够更快为浏览器加载高级语言），让桌面和移动端浏览器相比较网页或者应用的整体源代码变得更加高效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebAssembly.compile(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  00 61 73 6d  01 00 00 00  01 0c 02 60  02 7f 7f 01</span></span><br><span class="line"><span class="string">  7f 60 01 7f  01 7f 03 03  02 00 01 07  10 02 03 61</span></span><br><span class="line"><span class="string">  64 64 00 00  06 73 71 75  61 72 65 00  01 0a 13 02</span></span><br><span class="line"><span class="string">  08 00 20 00  20 01 6a 0f  0b 08 00 20  00 20 00 6c</span></span><br><span class="line"><span class="string">  0f 0b`</span>.trim().split(<span class="regexp">/[\s\r\n]+/g</span>).map(<span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str, <span class="number">16</span>))</span><br><span class="line">)).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; add, square &#125; = instance.exports</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2 + 4 ='</span>, add(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3^2 ='</span>, square(<span class="number">3</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'(2 + 5)^2 ='</span>, square(add(<span class="number">2</span> + <span class="number">5</span>)))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="一个工具"><a href="#一个工具" class="headerlink" title="一个工具"></a>一个工具</h3><p><a href="https://github.com/qiaozi-tech/SecurityWorker#4-securityworker-vm-api" target="_blank" rel="noopener">文档</a></p>
<p>混淆原理：<br><img src="/images/JS/JS%E6%B7%B7%E6%B7%86-webassembly.png" alt="JS混淆" title="混淆"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://blog.knownsec.com/2015/08/use-estools-aid-deobfuscate-javascript/" target="_blank" rel="noopener">https://blog.knownsec.com/2015/08/use-estools-aid-deobfuscate-javascript/</a></li>
<li><a href="https://github.com/qiaozi-tech/SecurityWorker#4-securityworker-vm-api" target="_blank" rel="noopener">https://github.com/qiaozi-tech/SecurityWorker#4-securityworker-vm-api</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS混淆</tag>
        <tag>AST</tag>
        <tag>webAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>JS生成AST及CFG</title>
    <url>/2020/04/21/JS%E7%94%9F%E6%88%90AST%E5%8F%8ACFG/</url>
    <content><![CDATA[<h2 id="JS生成AST"><a href="#JS生成AST" class="headerlink" title="JS生成AST"></a>JS生成AST</h2><p>AST：抽象语法树。通过对源码进行词法分析、语法分析生成抽象语法树。</p>
<p>JavaScript生成AST有许多工具，这里主要介绍一种 <strong>Esprima</strong> 的使用.</p>
<p><code>npm install esprima</code>开始使用<br><a href="https://esprima.readthedocs.io/en/4.0/index.html" target="_blank" rel="noopener">esprima文档</a></p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><code>esprima.parse(input, config, delegate)</code><br><a href="https://esprima.readthedocs.io/en/4.0/syntactic-analysis.html" target="_blank" rel="noopener">详情</a><br><a href="https://esprima.readthedocs.io/en/4.0/syntax-tree-format.html" target="_blank" rel="noopener">AST节点类型</a></p>
<ul>
<li>input is the string representing the program to be parsed</li>
<li>config is an object used to customize the parsing behavior (optional)</li>
<li>delegate is a callback function invoked for every single node (optional)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  使用</span></span><br><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`function foo() &#123;</span></span><br><span class="line"><span class="string">                let a = 1;</span></span><br><span class="line"><span class="string">                console.log(a)</span></span><br><span class="line"><span class="string">            &#125;`</span></span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    loc: <span class="literal">true</span>,  <span class="comment">//  位置信息</span></span><br><span class="line">    range: <span class="literal">false</span>,    <span class="comment">//  位置信息</span></span><br><span class="line">    jsx: <span class="literal">false</span>,  <span class="comment">//  支持jsx语法</span></span><br><span class="line">    tolerant: <span class="literal">false</span>,</span><br><span class="line">    tokens: <span class="literal">false</span>,</span><br><span class="line">    comment: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  回调函数里的 node 包含节点类型等信息，metadata 包含该节点位置等信息</span></span><br><span class="line"><span class="keyword">const</span> ast = esprima.parse(code, options, <span class="function"><span class="keyword">function</span> (<span class="params">node, metadata</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.type);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>生成的ast长成这样：<br><img src="/images/ast/ast.png" alt="ast" title="ast树"></p>
<h3 id="AST结构"><a href="#AST结构" class="headerlink" title="AST结构"></a>AST结构</h3><p>总体结构有两种</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Program &#123;</span><br><span class="line">  type: <span class="string">'Program'</span>;</span><br><span class="line">  sourceType: <span class="string">'script'</span>;</span><br><span class="line">  body: StatementListItem[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Program &#123;</span><br><span class="line">  type: <span class="string">'Program'</span>;</span><br><span class="line">  sourceType: <span class="string">'module'</span>;</span><br><span class="line">  body: ModuleItem[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StatementListItem-amp-amp-ModuleItem"><a href="#StatementListItem-amp-amp-ModuleItem" class="headerlink" title="StatementListItem &amp;&amp; ModuleItem"></a>StatementListItem &amp;&amp; ModuleItem</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;其中 ModuleItem 只是比 StatementListItem 多了导入和导出两个module才会用到的类型，这两个类型用的少，<strong>所以只用关心 StatementListItem</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type StatementListItem = Declaration | Statement;</span><br><span class="line">type ModuleItem = ImportDeclaration | ExportDeclaration | StatementListItem;</span><br></pre></td></tr></table></figure>
<p>StatementListItem 包含 Declaration(变量声明) 和 Statement(执行语句)</p>
<h5 id="Declaration变量声明"><a href="#Declaration变量声明" class="headerlink" title="Declaration变量声明"></a>Declaration变量声明</h5><p>变量声明的类型包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Declaration = ClassDeclaration | FunctionDeclaration | VariableDeclaration;</span><br></pre></td></tr></table></figure>
<h5 id="Statement执行语句"><a href="#Statement执行语句" class="headerlink" title="Statement执行语句"></a>Statement执行语句</h5><p>执行语句包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Statement = BlockStatement | BreakStatement | ContinueStatement |</span><br><span class="line">    DebuggerStatement | DoWhileStatement | EmptyStatement |</span><br><span class="line">    ExpressionStatement | ForStatement | ForInStatement |</span><br><span class="line">    ForOfStatement | FunctionDeclaration | IfStatement |</span><br><span class="line">    LabeledStatement | ReturnStatement | SwitchStatement |</span><br><span class="line">    ThrowStatement | TryStatement | VariableDeclaration |</span><br><span class="line">    WhileStatement | WithStatement;</span><br></pre></td></tr></table></figure>
<h6 id="ExpressionStatement"><a href="#ExpressionStatement" class="headerlink" title="ExpressionStatement"></a>ExpressionStatement</h6><p>ExpressionStatement最为复杂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ExpressionStatement &#123;</span><br><span class="line">    type: <span class="string">'ExpressionStatement'</span>;</span><br><span class="line">    expression: Expression;</span><br><span class="line">    directive: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Expression 类型</span></span><br><span class="line">type Expression = ThisExpression | Identifier | Literal |</span><br><span class="line">    ArrayExpression | ObjectExpression | FunctionExpression | </span><br><span class="line">    ArrowFunctionExpression | ClassExpression |</span><br><span class="line">    TaggedTemplateExpression | MemberExpression | </span><br><span class="line">    Super | MetaProperty | NewExpression | CallExpression | UpdateExpression | </span><br><span class="line">    AwaitExpression | UnaryExpression |</span><br><span class="line">    BinaryExpression | LogicalExpression | ConditionalExpression |</span><br><span class="line">    YieldExpression | AssignmentExpression | SequenceExpression;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ast树主要包括两种结构带有module的 <strong>moduleItem</strong> 和正常的 <strong>StatementListItem</strong>。<br>StatementListItem结构包括两种 <strong>变量声明</strong>、<strong>执行语句</strong>。</p>
<ul>
<li>变量声明(Declaration)包括<strong>函数，变量，类的声明</strong>。</li>
<li>执行语句(Statement)分为两大类： <ol>
<li>关键字组成的 statement，如 IfStatement, ForStatement等，这里面的BlockStatement有些特殊，因为其body又是StatementListItem，产生递归。</li>
<li>运算语句（赋值、计算之类的操作）组成的 ExpressionStatement。</li>
</ol>
</li>
</ul>
<h2 id="AST生成CFG"><a href="#AST生成CFG" class="headerlink" title="AST生成CFG"></a>AST生成CFG</h2><h3 id="使用Styx"><a href="#使用Styx" class="headerlink" title="使用Styx"></a>使用Styx</h3><p><a href="https://www.npmjs.com/package/styx" target="_blank" rel="noopener">npm</a>   <a href="https://github.com/mariusschulz/styx" target="_blank" rel="noopener">github</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Esprima <span class="keyword">from</span> <span class="string">"esprima"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Styx <span class="keyword">from</span> <span class="string">"styx"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> code = <span class="string">"var x = 2 + 2;"</span>;</span><br><span class="line"><span class="keyword">var</span> ast = Esprima.parse(code);</span><br><span class="line"><span class="keyword">var</span> flowProgram = Styx.parse(ast);</span><br><span class="line"><span class="keyword">var</span> json = Styx.exportAsJson(flowProgram);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>AST</tag>
        <tag>CFG</tag>
      </tags>
  </entry>
  <entry>
    <title>JS继承</title>
    <url>/2020/08/28/JS%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JS有好几种继承方式，常见的就是原型链继承和call改变指向</p>
<p>先看原型链是怎么回事，一图胜千言<br><img src="/images/JS/JS%E5%8E%9F%E5%9E%8B.png" alt="JS原型链" title="图片标题title"></p>
<h1 id="ES5的寄生组合继承"><a href="#ES5的寄生组合继承" class="headerlink" title="ES5的寄生组合继承"></a>ES5的寄生组合继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span> (<span class="params">age, value</span>) </span>&#123;</span><br><span class="line">    parent.call(<span class="keyword">this</span>, age)</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub.prototype = <span class="built_in">Object</span>.create(parent.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: sub,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  转换前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  转换后</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: <span class="string">"speakSomething"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">speakSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h2 id="class-extend原理"><a href="#class-extend原理" class="headerlink" title="class extend原理"></a>class extend原理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  转换前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> height = <span class="number">12</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.color = <span class="string">'yellow'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类，继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="number">18</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    coding()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can code JS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">"job"</span>,<span class="number">30</span>);</span><br><span class="line">c.coding()</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  转换后</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>) ? call : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function, not "</span> + <span class="keyword">typeof</span> superClass);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: <span class="string">"speakSomething"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">speakSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">Parent.height = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">Parent.prototype.color = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类，继承父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (Child.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Child)).call(<span class="keyword">this</span>, name, age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Child, [&#123;</span><br><span class="line">        key: <span class="string">"coding"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">coding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can code JS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent);</span><br><span class="line"></span><br><span class="line">Child.width = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">"job"</span>, <span class="number">30</span>);</span><br><span class="line">c.coding();</span><br></pre></td></tr></table></figure>


<p>_inherits核心思想就是下面两句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">subClass.prototype.__proto__ = superClass.prototype</span><br><span class="line">subClass.__proto__ = superClass</span><br></pre></td></tr></table></figure>

<p>首先 <code>subClass.prototype.__proto__ = superClass.prototype</code>保证了<code>c instanceof Parent</code>是<code>true</code>，<code>Child</code>的实例可以访问到父类的属性，包括内部属性，以及原型属性。其次，<code>subClass.__proto__ = superClass</code>，保证了<code>Child.height</code>也能访问到，也就是静态方法。</p>
<p><code>subClass.__proto__ = superClass</code>不是很好理解，可以通过下面的方式理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A()</span><br><span class="line">a.__proto__ = A.prototype</span><br></pre></td></tr></table></figure>

<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。</p>
<p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000014798678" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014798678</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/04/19/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>逐级递减，#后需要一个空格才生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<!-- [^RUNOOB]: 学的不仅是技术，更是梦想！！！ -->

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片标题title&quot;)</span><br><span class="line">eg: ![tcp详情](&#x2F;images&#x2F;http&#x2F;tcp2.png &quot;图片标题&quot;)</span><br></pre></td></tr></table></figure>
<p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://chjssg.github.io/" target="_blank" rel="noopener">chj的博客</a><br><a href="https://chjssg.github.io/" target="_blank" rel="noopener">https://chjssg.github.io/</a></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容1</span><br><span class="line">+ 列表内容2</span><br><span class="line">* 列表内容3</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<ul>
<li>列表内容1</li>
</ul>
<ul>
<li>列表内容2</li>
</ul>
<ul>
<li>列表内容3</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上一级和下一级之间敲三个空格即可</span><br><span class="line">eg:</span><br><span class="line">1. 列表内容</span><br><span class="line">   - 列表内容1</span><br><span class="line">   + 列表内容2</span><br><span class="line">   * 列表内容3</span><br><span class="line">   &gt; 列表内容4</span><br><span class="line">2. 列表内容</span><br><span class="line">   &gt; 列表内容4</span><br><span class="line">   &gt; 列表内容5</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure>
<ol>
<li>列表内容<ul>
<li>列表内容1</li>
</ul>
<ul>
<li>列表内容2</li>
</ul>
<ul>
<li>列表内容3</li>
</ul>
</li>
<li>列表内容<blockquote>
<p>列表内容4<br>列表内容5</p>
</blockquote>
</li>
<li>列表内容</li>
</ol>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line"></span><br><span class="line">-: 设置内容和标题栏居右对齐。</span><br><span class="line">:- 设置内容和标题栏居左对齐。</span><br><span class="line">:-: 设置内容和标题栏居中对齐。</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>


<hr>
<hr>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个反引号包裹</span><br><span class="line">eg: &#96;代码示例&#96;</span><br></pre></td></tr></table></figure>
<p><code>console.log(&#39;代码示例&#39;)</code></p>
<h4 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h4><p>使用三个反引号包裹且各占一行</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="支持HTML"><a href="#支持HTML" class="headerlink" title="支持HTML"></a>支持HTML</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</span><br><span class="line">目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等</span><br></pre></td></tr></table></figure>

<p>eg:<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>反斜杠转义</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</p>
<!-- 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 -->

<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>新建草稿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft  &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>预览草稿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure>
<p>发布：将草稿发布为文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>原理就是两个文件夹的相互切换</p>
]]></content>
      <categories>
        <category>Hexo使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex详解</title>
    <url>/2020/08/30/Vuex%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue中runtime-compiler和runtime-only</title>
    <url>/2020/09/27/Vue%E4%B8%ADruntime-compiler%E5%92%8Cruntime-only/</url>
    <content><![CDATA[<p>在使用vue-cli创建项目时候会选择使用<code>runtime-compile</code>还是<code>runtime-only</code>模式.<br>目前在vue-cli2会有此选项，vuecli3没有了。</p>
<h1 id="runtime-only"><a href="#runtime-only" class="headerlink" title="runtime-only"></a>runtime-only</h1><p>我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="runtime-compiler"><a href="#runtime-compiler" class="headerlink" title="runtime-compiler"></a>runtime-compiler</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: &#123;App&#125;,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="比对"><a href="#比对" class="headerlink" title="比对"></a>比对</h1><p>runtime-compiler流程为： template-&gt;AST-&gt;render-&gt;VDOM-&gt;真实DOM-&gt;页面</p>
<p>runtime-only直接就是render这一流程 </p>
<p>如果你需要在客户端编译模板 (比如传入一个字符串给 template 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)，就将需要加上编译器，即完整版(runtime-compiler)<br>如果使用runtime-only就会报错</p>
<p><a href="https://www.jianshu.com/p/affa58db63d9" target="_blank" rel="noopener">https://www.jianshu.com/p/affa58db63d9</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码之solt</title>
    <url>/2020/10/11/Vue%E6%BA%90%E7%A0%81%E4%B9%8Bsolt/</url>
    <content><![CDATA[<h1 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>solt是Vue的一个特性-插槽</p>
<p>它允许你像这样合成组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span> <span class="attr">class</span>=<span class="string">"nav-link"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每个solt需要分配一个name值，默认name值为default</p>
<h2 id="源码过程"><a href="#源码过程" class="headerlink" title="源码过程"></a>源码过程</h2><p><img src="/images/vue/solt%E6%99%AE%E9%80%9A.jpg" alt="普通solt" title="图片标题"></p>
<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定在 <slot> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p><a href="https://zhuanlan.zhihu.com/p/57570713" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57570713</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>solt</category>
      </categories>
      <tags>
        <tag>vue源码</tag>
        <tag>solt</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue之keep-alive原理</title>
    <url>/2020/08/30/Vue%E4%B9%8Bkeep-alive%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="keep-alive是什么？"><a href="#keep-alive是什么？" class="headerlink" title="keep-alive是什么？"></a>keep-alive是什么？</h1><p>keep-alive是Vue的一个内置组件，用来缓存keep-alive内节点，当下次在访问的时候会命中缓存，降低请求数量及防止重复渲染dom。接受三个属性，include,exclude,max。<br>keep-alive是一个抽象组件，根据<code>abstract: true</code>判断：其节点不会渲染到页面中。<br>含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated</p>
<ol>
<li>activated 当 keepalive 包含的组件再次渲染的时候触发</li>
<li>deactivated 当 keepalive 包含的组件销毁的时候触发</li>
</ol>
<h1 id="keep-alive源码"><a href="#keep-alive源码" class="headerlink" title="keep-alive源码"></a>keep-alive源码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)     <span class="comment">//创建一个缓存的空对象</span></span><br><span class="line">    <span class="keyword">this</span>.keys = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">        <span class="comment">//  销毁所有组件</span></span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache, key, <span class="keyword">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted () &#123;</span><br><span class="line">      <span class="comment">//监听 include 数据是否有变化</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'include'</span>, val =&gt; &#123;</span><br><span class="line">      <span class="comment">//判断include 对象中 name 不存在了 就 调用 检测缓存中的组件，如果不是当前激活的组件则销毁</span></span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听 exclude 数据是否有变化</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'exclude'</span>, val =&gt; &#123;</span><br><span class="line">      <span class="comment">//如果exclude 对象中存在name 不存在了 就 调用 检测缓存中的组件，如果不是当前激活的组件则销毁</span></span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> slot = <span class="keyword">this</span>.$slots.default    <span class="comment">//获取插槽</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 获取插槽子组件</span></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions    <span class="comment">//获取组件参数</span></span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">//获取组件名称</span></span><br><span class="line">      <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="keyword">this</span> <span class="comment">//获取include exclude</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="keyword">this</span> <span class="comment">//缓存的对象、keys</span></span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123; <span class="comment">//获取值 如果key存在</span></span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance <span class="comment">//直接获取组件实例化</span></span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key)   <span class="comment">//把key添加到末端</span></span><br><span class="line">        keys.push(key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将虚拟dom缓存起来</span></span><br><span class="line">        cache[key] = vnode</span><br><span class="line">        keys.push(key) <span class="comment">//key缓存起来</span></span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://juejin.im/post/6844903837770203144" target="_blank" rel="noopener">https://juejin.im/post/6844903837770203144</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>keep-alive</category>
      </categories>
      <tags>
        <tag>vue源码</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title>element源码解析-组件间通信方式</title>
    <url>/2020/10/12/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>element的组件通信用了广播的方式<br>从 <code>/src/mixins/emitter.js</code> 中可以看出，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广播方法定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>String componentName 组件名称 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>String eventName 事件名称 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>Object params 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历子组件，对子组件的name进行匹配</span></span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = child.$options.componentName;</span><br><span class="line">    <span class="comment">// 当子组件中的名称匹配到传入的componentName时，在子组件中传入该事件并传递params</span></span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      <span class="comment">// 子组件中与传入的componentName相等时，则在子组件中执行eventName方法，参数为params</span></span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不存在则继续执行broadcast方法，this指向子组件</span></span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      <span class="comment">// 定义父组件对象，如果该组件上面没有对象，则parent为根组件</span></span><br><span class="line">      <span class="keyword">var</span> parent = <span class="keyword">this</span>.$parent || <span class="keyword">this</span>.$root;</span><br><span class="line">      <span class="keyword">var</span> name = parent.$options.componentName; <span class="comment">// 父组件名称</span></span><br><span class="line">      <span class="comment">// 当父组件对象存在时且父组件名称不等于componentName时，则改变parent值，并将parent值向上赋值；当parent不存在或者name === componentName时，跳出循环</span></span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent; <span class="comment">// parent向上赋值</span></span><br><span class="line">        <span class="comment">// 如果parent存在（即之前的parent含有$parent时）</span></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// name === componentName时，则在改组件中执行eventName方法，参数为params</span></span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(<span class="keyword">this</span>, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>broadcast方法是遍历当前组件相应子组件找到匹配的 <code>componentName</code> 然后触发vue原生的 $emit 方法。然后一直轮询找到对应组件</li>
<li>dispatch方法是遍历父组件，直到找到匹配的 <code>componentName</code>然后触发vue原生的 $emit 方法。<br>当然，每一个$emit方法需要一个$on方法接受数据，$on是提前定义在 对应<code>componentName</code>内的</li>
</ol>
]]></content>
      <categories>
        <category>element源码</category>
        <category>组件通信</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>element源码解析</title>
    <url>/2020/09/13/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>element版本：2.13.2<br>Vue版本：”^2.5.17”</p>
<h1 id="先来看整体的目录结构"><a href="#先来看整体的目录结构" class="headerlink" title="先来看整体的目录结构"></a>先来看整体的目录结构</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|-- Element</span><br><span class="line">  |--packages   <span class="comment">//  组件源码</span></span><br><span class="line">  |--examples   <span class="comment">//  官方主页源码</span></span><br><span class="line">  |--build  <span class="comment">//  webpack编译配置文件</span></span><br><span class="line">  |--src    <span class="comment">//  项目使用到的公共指令、工具集等源码存放目录</span></span><br><span class="line">  |-- test <span class="comment">// 单元测试相关</span></span><br><span class="line">  |-- types <span class="comment">// typescript相关文件包</span></span><br><span class="line">  |-- lib <span class="comment">// 打包后的文件目录</span></span><br><span class="line"></span><br><span class="line">  |-- package.json</span><br><span class="line">  |-- components.json <span class="comment">// 组件列表（所有组件）文件</span></span><br><span class="line">  |-- README.md <span class="comment">// 项目说明文件</span></span><br><span class="line"></span><br><span class="line">  |-- .babelrc <span class="comment">// babel配置文件</span></span><br><span class="line">  |-- .eslintignore <span class="comment">// eslint校验忽略文件</span></span><br><span class="line">​  |-- .eslintrc <span class="comment">// eslint配置文件</span></span><br><span class="line">​  |-- .gitattributes <span class="comment">// git属性配置文件</span></span><br><span class="line">​  |-- .gitignore <span class="comment">// git忽略追踪管理的文件</span></span><br><span class="line">​  |-- .travis.yml <span class="comment">// 持续集成配置文件</span></span><br><span class="line">​  </span><br><span class="line">  |-- FAQ.md <span class="comment">// 常见问题说明文档</span></span><br><span class="line">  |-- Makefile <span class="comment">// 自动化编译配置文件</span></span><br><span class="line">  |-- postcss.config.js <span class="comment">// postcss配置文件</span></span><br><span class="line">​  </span><br><span class="line">  |-- CHANGELOG.en-US.md <span class="comment">// 版本改变点log文件-英文版</span></span><br><span class="line">​  |-- CHANGELOG.es.md</span><br><span class="line">  |-- CHANGELOG.zh-CN.md <span class="comment">// 版本改变点log文件-中文版</span></span><br><span class="line">​  |-- element_logo.svg <span class="comment">// logo svg文件</span></span><br><span class="line">​  |-- yarn.lock  <span class="comment">// yarn配置文件</span></span><br><span class="line">  |-- LICENSE <span class="comment">// 开源协议</span></span><br></pre></td></tr></table></figure>

<h1 id="工程化架构"><a href="#工程化架构" class="headerlink" title="工程化架构"></a>工程化架构</h1><p>ele的工程化是如何做的呢？<br>我们先来看package.json的命令有哪些</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "bootstrap": "yarn || npm i",</span><br><span class="line">    "build:file": "node build/bin/iconInit.js &amp; node build/bin/build-entry.js &amp; node build/bin/i18n.js &amp; node build/bin/version.js",</span><br><span class="line">    "build:theme": "node build/bin/gen-cssfile &amp;&amp; gulp build --gulpfile packages/theme-chalk/gulpfile.js &amp;&amp; cp-cli packages/theme-chalk/lib lib/theme-chalk",</span><br><span class="line">    "build:utils": "cross-env BABEL_ENV=utils babel src --out-dir lib --ignore src/index.js",</span><br><span class="line">    "build:umd": "node build/bin/build-locale.js",</span><br><span class="line">    "clean": "rimraf lib &amp;&amp; rimraf packages/*/lib &amp;&amp; rimraf test/**/coverage",</span><br><span class="line">    "deploy:build": "npm run build:file &amp;&amp; cross-env NODE_ENV=production webpack --config build/webpack.demo.js &amp;&amp; echo element.eleme.io&gt;&gt;examples/element-ui/CNAME",</span><br><span class="line">    "deploy:extension": "cross-env NODE_ENV=production webpack --config build/webpack.extension.js",</span><br><span class="line">    "dev:extension": "rimraf examples/extension/dist &amp;&amp; cross-env NODE_ENV=development webpack --watch --config build/webpack.extension.js",</span><br><span class="line">    "dev": "npm run build:file &amp;&amp; cross-env NODE_ENV=development webpack-dev-server --config build/webpack.demo.js &amp; node build/bin/template.js",</span><br><span class="line">    "dev:play": "npm run build:file &amp;&amp; cross-env NODE_ENV=development PLAY_ENV=true webpack-dev-server --config build/webpack.demo.js",</span><br><span class="line">    "dist": "npm run clean &amp;&amp; npm run build:file &amp;&amp; npm run lint &amp;&amp; webpack --config build/webpack.conf.js &amp;&amp; webpack --config build/webpack.common.js &amp;&amp; webpack --config build/webpack.component.js &amp;&amp; npm run build:utils &amp;&amp; npm run build:umd &amp;&amp; npm run build:theme",</span><br><span class="line">    "i18n": "node build/bin/i18n.js",</span><br><span class="line">    "lint": "eslint src/**/* test/**/* packages/**/* build/**/* --quiet",</span><br><span class="line">    "pub": "npm run bootstrap &amp;&amp; sh build/git-release.sh &amp;&amp; sh build/release.sh &amp;&amp; node build/bin/gen-indices.js &amp;&amp; sh build/deploy-faas.sh",</span><br><span class="line">    "test": "npm run lint &amp;&amp; npm run build:theme &amp;&amp; cross-env CI_ENV=/dev/ BABEL_ENV=test karma start test/unit/karma.conf.js --single-run",</span><br><span class="line">    "test:watch": "npm run build:theme &amp;&amp; cross-env BABEL_ENV=test karma start test/unit/karma.conf.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于-amp-与-amp-amp-区别"><a href="#关于-amp-与-amp-amp-区别" class="headerlink" title="关于 &amp; 与 &amp;&amp; 区别"></a>关于 &amp; 与 &amp;&amp; 区别</h2><p>说明：&amp;和&amp;&amp;都是逻辑运算符，都是判断两边同时真则为真，否则为假；<br>但是&amp;&amp;当第一个条件不成之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止</p>
<h2 id="npm-run-bootstrap"><a href="#npm-run-bootstrap" class="headerlink" title="npm run bootstrap"></a>npm run bootstrap</h2><p>下载依赖</p>
<h2 id="npm-run-build-file"><a href="#npm-run-build-file" class="headerlink" title="npm run build:file"></a>npm run build:file</h2><p>生成目标文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node build/bin/iconInit.js &amp;    <span class="comment">//  解析theme-chalk/src/icon.scss文件 生成 icon</span></span><br><span class="line">node build/bin/build-entry.js &amp; <span class="comment">//  根据components.json，生成入口文件</span></span><br><span class="line">node build/bin/i18n.js &amp;    <span class="comment">//  根据examples/i18n/page.json和模板，生成不同语言的demo</span></span><br><span class="line">node build/bin/version.js   <span class="comment">//  生成版本信息</span></span><br></pre></td></tr></table></figure>
<p>主要包含以上四个命令</p>
<h2 id="npm-run-build-theme"><a href="#npm-run-build-theme" class="headerlink" title="npm run build:theme"></a>npm run build:theme</h2><p>构建主题相关</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node build/bin/gen-cssfile &amp;&amp;   <span class="comment">//  生成各个组件的汇总样式css文件</span></span><br><span class="line">gulp build --gulpfile packages/theme-chalk/gulpfile.js &amp;&amp;</span><br><span class="line">cp-cli packages/theme-chalk/lib lib/theme-chalk   <span class="comment">//  将packages/theme-chalk/lib拷贝到lib/theme-chalk</span></span><br></pre></td></tr></table></figure>

<h2 id="npm-run-build-utils"><a href="#npm-run-build-utils" class="headerlink" title="npm run build:utils"></a>npm run build:utils</h2><p>设置环境变量 process.env.BABEL_ENV的值为utils，同时用babel命令编译整个src文件夹，并且将结果输出到lib文件夹下，lib不会去覆盖原来lib下的内容，编译时忽略’src/index.js’文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cross-env BABEL_ENV=utils babel src --out-dir lib --ignore src/index.js</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-build-umd"><a href="#npm-run-build-umd" class="headerlink" title="npm run build:umd"></a>npm run build:umd</h2><p>这个是把组件中所有的多语言都转换成当下环境的语言，<br>可以去 src/locale/lang 中查看所有文件，<br>主要是日期选择器里面的本地化和一些组件的默认加载状态的文字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node build/bin/build-locale.js</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-clean"><a href="#npm-run-clean" class="headerlink" title="npm run clean"></a>npm run clean</h2><p>清楚文件<br><code>rimraf lib &amp;&amp; rimraf packages/*/lib &amp;&amp; rimraf test/**/coverage</code></p>
<h2 id="npm-run-deploy-build"><a href="#npm-run-deploy-build" class="headerlink" title="npm run deploy:build"></a>npm run deploy:build</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build:file &amp;&amp; </span><br><span class="line">cross-env NODE_ENV=production webpack --config build/webpack.demo.js &amp;&amp; </span><br><span class="line">echo element.eleme.io&gt;&gt;examples/element-ui/CNAME</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-deploy-extension"><a href="#npm-run-deploy-extension" class="headerlink" title="npm run deploy:extension"></a>npm run deploy:extension</h2><p><code>cross-env NODE_ENV=production webpack --config build/webpack.extension.js</code></p>
<h2 id="npm-run-dev-extension"><a href="#npm-run-dev-extension" class="headerlink" title="npm run dev:extension"></a>npm run dev:extension</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rimraf examples/extension/dist &amp;&amp; </span><br><span class="line">cross-env NODE_ENV=development webpack --watch --config build/webpack.extension.js</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build:file &amp;&amp;</span><br><span class="line">cross-env NODE_ENV=development webpack-dev-server --config build/webpack.demo.js &amp;</span><br><span class="line">node build/bin/template.js</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-dev-play"><a href="#npm-run-dev-play" class="headerlink" title="npm run dev:play"></a>npm run dev:play</h2><p>与 dev 相比少了安装的步骤，以及后面的 template.js的构建，多了个 PLAY_ENV=true</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run build:file &amp;&amp;</span><br><span class="line">cross-env NODE_ENV=development PLAY_ENV=<span class="literal">true</span> webpack-dev-server --config build/webpack.demo.js</span><br></pre></td></tr></table></figure>

<h2 id="npm-run-dist"><a href="#npm-run-dist" class="headerlink" title="npm run dist"></a>npm run dist</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run clean &amp;&amp;    <span class="comment">//先清理环境</span></span><br><span class="line">npm run build:file &amp;&amp; <span class="comment">//构建文件</span></span><br><span class="line">npm run lint &amp;&amp;  <span class="comment">// 代码检查</span></span><br><span class="line">webpack --config build/webpack.conf.js &amp;&amp;   </span><br><span class="line">webpack --config build/webpack.common.js &amp;&amp;</span><br><span class="line">webpack --config build/webpack.component.js &amp;&amp;</span><br><span class="line">npm run build:utils &amp;&amp;</span><br><span class="line">npm run build:umd &amp;&amp;    <span class="comment">//  构建多语言</span></span><br><span class="line">npm run build:theme</span><br></pre></td></tr></table></figure>
<p>打包生成最终的代码，这应该是最全的了</p>
<h2 id="npm-run-i18n"><a href="#npm-run-i18n" class="headerlink" title="npm run i18n"></a>npm run i18n</h2><p>国际化<br><code>node build/bin/i18n.js</code></p>
<h2 id="npm-run-lint"><a href="#npm-run-lint" class="headerlink" title="npm run lint"></a>npm run lint</h2><p>代码检查<br><code>eslint src/**/* test/**/* packages/**/* build/**/* --quiet</code></p>
<h2 id="生成新组件"><a href="#生成新组件" class="headerlink" title="生成新组件"></a>生成新组件</h2><p><code>node build/bin/new.js &lt;new-component&gt;</code></p>
]]></content>
      <categories>
        <category>element源码</category>
        <category>目录及工程化详情</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>https与ssl证书</title>
    <url>/2020/09/20/https%E4%B8%8Essl%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="htttp-与https-区别"><a href="#htttp-与https-区别" class="headerlink" title="htttp 与https 区别"></a>htttp 与https 区别</h1><ol>
<li>http的传输都是未经过加密的明文，https利用http来传输但是使用SSL/TSL加密传输信息。比http更加安全</li>
<li>http占用80端口，https占用443端口</li>
</ol>
<h1 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h1><ol>
<li>客户端向服务端发送自己支持的加密算法</li>
<li>服务端返回客户端一个证书，包括公钥</li>
<li>验证证书合法性，浏览器端生成随机数，利用公钥对随机数进行加密传到服务端</li>
<li>服务端利用私钥解密得到随机数，然后利用随机数进行对称加密，将信息传到客户端</li>
<li>客户端解密得到信息</li>
</ol>
<h1 id="关于证书"><a href="#关于证书" class="headerlink" title="关于证书"></a>关于证书</h1><p>上述的第二步就是服务端给客户端SSL证书的过程。<br>SSL证书可以理解为一个身份证，包括颁发机构、网站地址、过期时间及公钥信息。<br>浏览器会根据这些信息对证书进行验证，如果验证失败会给出提示</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/w3cnote/https-ssl-intro.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/https-ssl-intro.html</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https基础</tag>
      </tags>
  </entry>
  <entry>
    <title>《HTTP权威指南》读书笔记---第一部分</title>
    <url>/2020/04/20/http%E4%B9%8B%E3%80%8AHTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>这一部分讲1~4章，简述HTTP协议。</p>
<h3 id="第一章：http概述"><a href="#第一章：http概述" class="headerlink" title="第一章：http概述"></a>第一章：http概述</h3><p>主要讲述HTTP如何工作的。</p>
<p><strong>web客户端与服务端</strong>：web服务器上存储着内容，客户端通过HTTP协议向HTTP服务器请求响应内容。web客户端与服务端是基本组件。</p>
<p><strong>资源</strong>：web服务器是web资源的宿主。静态文件（.img、.html、.avi）可以是资源，软件代码可以是资源，搜索引擎可以是资源等等。MIME用来表示数据类型，即header 头 content-type。使用URI（统一资源定位符）来标识资源</p>
<h3 id="第二章：http概述"><a href="#第二章：http概述" class="headerlink" title="第二章：http概述"></a>第二章：http概述</h3><p><strong>URL编码</strong>：为了在URL表示不安全的字符设置了一套编码机制，原理是通过%加上十六进制来表示这些字符。比如“\” 他的ASCII码为92，92的十六进制是5c，所以“\” 在URL里表示为“%5c”。</p>
<p><strong>方案格式</strong>：除了可以使用http://表示URL外，还有 file:// 用来表示文件，https:// 在http的tcp协议上加了一层ssl,比http://更安全，fcp://等等</p>
<h3 id="第三章：http报文"><a href="#第三章：http报文" class="headerlink" title="第三章：http报文"></a>第三章：http报文</h3><p>报文是在HTTP应用程序之间流动发送的数据块，数据块以文本特定格式发送。报文分为请求报文与响应报文。</p>
<p><strong>报文格式</strong>：起始行，首部和主体三部分。起始行和首部是一段ASCII码，主体是可选的数据块，可为二进制数据也可为文本。起始行与首部用两个字符组成的CRLF分割其分别为回车符(CR，ASCII 13，\r，%0d) 和换行符(LF，ASCII 10，\n，%0a)。首部与主体以一行空白作为分割。<br><img src="/images/http/baowen.png" alt="报文格式" title="报文格式"><br><strong>方法</strong>：put,delete,trace,post,get,options(服务器支持哪些方法)，head</p>
<p><strong>状态码</strong>：100-199信息状态码（100：表示服务器接收到请求，请客户端继续发送），200-299成功状态码，300-399重定向状态码，400-499客户端错误，500-599服务器错误</p>
<h3 id="第四章：连接管理"><a href="#第四章：连接管理" class="headerlink" title="第四章：连接管理"></a>第四章：连接管理</h3><h4 id="什么是tcp"><a href="#什么是tcp" class="headerlink" title="什么是tcp?"></a>什么是tcp?</h4><p><img src="/images/http/tcp1.png" alt="url解析" title="url解析"><br>如上图在浏览器与服务器进行80端口连接的时候就会进行TCP连接。HTTP要传输报文时，会将报文将流的形式按顺序以TCP传输，TCP收到数据后会将数据块分成一个个小段数据块以IP分组的形式通过互联网传输。TCP数据块是由一个个小的IP分组数据块组成，如下图所示。可以看到一个IP分组包含IP首部，TCP首部以及TCP数据块。TCP首部有一些标志用来进行连接检查等操作。</p>
<p><img src="/images/http/tcp2.png" alt="tcp详情" title="tcp详情"></p>
<h4 id="TCP是如何连接的？"><a href="#TCP是如何连接的？" class="headerlink" title="TCP是如何连接的？"></a>TCP是如何连接的？</h4><p>TCP连接需要经过以下几个步骤？</p>
<p>客户端向服务端发送一个小的TCP分组，设置一个特殊的SYN标记表示这是一个连接请求<br>服务器接到请求并接受连接后会向客户端回送一个TCP分组，将SYN和ACK标志位置位表示接受连接请求<br>客户端接受后会回送一个确认消息，通知连接已经建立。现代的TCP栈允许在这个确认分组中发送数据。<br>这一过程称作TCP三次握手</p>
<h4 id="TCP性能"><a href="#TCP性能" class="headerlink" title="TCP性能"></a>TCP性能</h4><p>由于HTTP是构建TCP上，所以TCP的性能直接就反映了HTTP的性能。在一个HTTP事务出现时延有以下可能：</p>
<ol>
<li>DNS解析域名的时间。</li>
<li>TCP连接建立时延。</li>
<li>HTTP请求时延。</li>
<li>HTTP响应时延。</li>
</ol>
<p>其中TCP时延包括：</p>
<ol>
<li>TCP握手时延。</li>
<li>TCP慢启动拥塞控制。</li>
<li>数据聚焦的Nagle算法。</li>
<li>捎带确认的TCP延迟确认算法。</li>
<li>TIME_WAIT时延和端口耗尽。</li>
</ol>
<p>其中TCP慢启动在起初会限制连接的最大速度，然后随着时间提高传输速度，以防止网络拥塞和突然过载。</p>
<p>还有几种方法可以提高HTTP连接性能：</p>
<ul>
<li>并行连接（通过连接多条TCP提高性能）</li>
<li>持久连接（重用TCP连接，消除连接关闭时延）</li>
<li>管道化连接（通过共享的TCP连接发起并发的HTTP连接）</li>
<li>复用的连接（交替传送请求响应报文）</li>
</ul>
<p>持久化连接即http头 connection： keep-alive。http1.0手动开启，http1.1后默认开启。</p>
<p>管道化连接就是持久化连接与并行连接的合并版</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http基础</tag>
      </tags>
  </entry>
  <entry>
    <title>koa与express的中间件机制</title>
    <url>/2020/10/19/koa%E4%B8%8Eexpress%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>仔细看一下koa除了调用next的时候前面加了一个await好像和express没有任何区别，都是函数嵌套，都是洋葱模型。但是咱们回过头再仔细看一下文章最上面koa的运行代码，koa是在哪里响应的用户请求呢？koa中好型并没有cxt.send这样的函数，只有cxt.body，但是调用cxt.body并不是直接结束请求返回响应啊，和express的res.send有着本质上的不同。下面引用一段其他网友总结的express和koa中间件机制的不同，我个人感觉总结的很到位：</p>
<p>其实中间件执行逻辑没有什么特别的不同，都是依赖函数调用栈的执行顺序，抬杠一点讲都可以叫做洋葱模型。Koa 依靠 async/await（generator + co）让异步操作可以变成同步写法，更好理解。最关键的不是这些中间的执行顺序，而是响应的时机，Express 使用 res.end() 是立即返回，这样想要做出些响应前的操作变得比较麻烦；而 Koa 是在所有中间件中使用 ctx.body 设置响应数据，但是并不立即响应，而是在所有中间件执行结束后，再调用 res.end(ctx.body) 进行响应，这样就为响应前的操作预留了空间，所以是请求与响应都在最外层，中间件处理是一层层进行，所以被理解成洋葱模型，个人拙见。<br><a href="https://cloud.tencent.com/developer/article/1467268" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1467268</a></p>
]]></content>
  </entry>
  <entry>
    <title>js之深拷贝</title>
    <url>/2020/04/20/js%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>JS中对象存储在堆中，对象赋值给变量的过程中实际是把对象在堆中的地址赋值给变量。所以在将一个对象赋值给多个变量时实际是地址赋值给多个变量，实际是一个对象。在改变对象内值得同时如不进行深拷贝也会影响到其他变量。</p>
<h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><h3 id="JSON-sringify-和-JSON-parse"><a href="#JSON-sringify-和-JSON-parse" class="headerlink" title="JSON.sringify 和 JSON.parse"></a>JSON.sringify 和 JSON.parse</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  将对象转换为字符串，在通过parse进行解析重新建立对象</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(obj))</span><br></pre></td></tr></table></figure>
<p>弊端：</p>
<ul>
<li>不能复制function、正则、Symbol、Error对象</li>
<li>循环引用报错</li>
<li>相同的引用会被重复复制</li>
<li>如果是时间对象将会得到字符串，而不再是一个时间对象</li>
</ul>
<h3 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepcopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">var</span> deepobj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? []:&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">// 判断是否为自身属性而非继承属性</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">typeof</span> obj[key] === <span class="string">"object"</span> ? deepobj[key] = deepcopy(obj[key]): deepobj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(deepobj)</span><br><span class="line">    <span class="keyword">return</span> deepobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>element源码解析-样式</title>
    <url>/2020/09/14/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>作为这样一个庞大的组件库，样式是如何管理的呢？</p>
<p>首先element的样式全都放在了 theme-chalk 文件夹里，与组件一起放在了packages里。<br>element使用sass管理样式</p>
<h1 id="总目录"><a href="#总目录" class="headerlink" title="总目录"></a>总目录</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">|-- theme-chalk</span><br><span class="line">  |-- src</span><br><span class="line">    |-- common   // </span><br><span class="line">    |-- date-picker   //  </span><br><span class="line">    |-- fonts  //  icon相关</span><br><span class="line">    |-- mixins    //  混入，公用代码文件夹</span><br><span class="line">      |-- _function.scss</span><br><span class="line">      |-- config.scss</span><br><span class="line">      |-- function.scss  </span><br><span class="line">      |-- utils.scss </span><br><span class="line">      |-- mixins.scss</span><br><span class="line">    |-- index.scss // 各个组件样式汇总文件</span><br><span class="line">    |-- alert.scss // 弹框组件样式</span><br><span class="line">    |-- ... // 其他组件样式</span><br><span class="line"></span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- components.json // 组件列表（所有组件）文件</span><br><span class="line">    |-- README.md // 项目说明文件</span><br><span class="line">  |--gulpfiles.js   //  构建样式生成css文件</span><br></pre></td></tr></table></figure>

<h2 id="mixins详解"><a href="#mixins详解" class="headerlink" title="mixins详解"></a>mixins详解</h2><h3 id="config-scss"><a href="#config-scss" class="headerlink" title="config.scss"></a>config.scss</h3><p>定义一些原始值</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$namespace</span>: <span class="string">'el'</span>;   <span class="comment">//  命名空间</span></span><br><span class="line"><span class="variable">$element-separator</span>: <span class="string">'__'</span>;   <span class="comment">//  元素分隔符</span></span><br><span class="line"><span class="variable">$modifier-separator</span>: <span class="string">'--'</span>;  <span class="comment">//  修饰符分隔符</span></span><br><span class="line"><span class="variable">$state-prefix</span>: <span class="string">'is-'</span>;   <span class="comment">//  状态标识前缀</span></span><br></pre></td></tr></table></figure>

<h3 id="function。scss"><a href="#function。scss" class="headerlink" title="function。scss"></a>function。scss</h3><p>定义一些函数</p>
<h3 id="mixins-scss"><a href="#mixins-scss" class="headerlink" title="mixins.scss"></a>mixins.scss</h3><p>bem命名规范<br>B(代表块)__E(代表元素)–M(代表修饰符)</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"function"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"../common/var"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Break-points</span></span><br><span class="line"><span class="comment"> -------------------------- */</span></span><br><span class="line"><span class="keyword">@mixin</span> res(<span class="variable">$key</span>, <span class="variable">$map</span>: <span class="variable">$--breakpoints</span>) &#123;</span><br><span class="line">  <span class="comment">// 循环断点Map，如果存在则返回</span></span><br><span class="line">  <span class="keyword">@if</span> map-has-key(<span class="variable">$map</span>, <span class="variable">$key</span>) &#123;</span><br><span class="line">    <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> #&#123;inspect(<span class="selector-tag">map</span>-get(<span class="variable">$map</span>, <span class="variable">$key</span>))&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@warn</span> <span class="string">"Undefeined points: `#&#123;$map&#125;`"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scrollbar</span></span><br><span class="line"><span class="comment"> -------------------------- */</span></span><br><span class="line"><span class="keyword">@mixin</span> scroll-bar &#123;</span><br><span class="line">  <span class="variable">$--scrollbar-thumb-background</span>: <span class="number">#b4bccc</span>;</span><br><span class="line">  <span class="variable">$--scrollbar-track-background</span>: <span class="number">#fff</span>;</span><br><span class="line"></span><br><span class="line">  &amp;::-webkit-scrollbar &#123;</span><br><span class="line">    z-index: <span class="number">11</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line"></span><br><span class="line">    &amp;:horizontal &#123;</span><br><span class="line">      height: <span class="number">6px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;-thumb &#123;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">      <span class="attribute">background</span>: <span class="variable">$--scrollbar-thumb-background</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;-corner &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="variable">$--scrollbar-track-background</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;-track &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="variable">$--scrollbar-track-background</span>;</span><br><span class="line"></span><br><span class="line">      &amp;-piece &#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="variable">$--scrollbar-track-background</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Placeholder</span></span><br><span class="line"><span class="comment"> -------------------------- */</span></span><br><span class="line"><span class="keyword">@mixin</span> placeholder &#123;</span><br><span class="line">  &amp;::-webkit-input-placeholder &#123;</span><br><span class="line">    @content</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;::-moz-placeholder &#123;</span><br><span class="line">    @content</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;:-ms-input-placeholder &#123;</span><br><span class="line">    @content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BEM</span></span><br><span class="line"><span class="comment"> -------------------------- */</span></span><br><span class="line"><span class="comment">/*添加命名空间*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> b(<span class="variable">$block</span>) &#123;</span><br><span class="line">  <span class="variable">$B</span>: <span class="variable">$namespace</span>+<span class="string">'-'</span>+<span class="variable">$block</span> !global;</span><br><span class="line"></span><br><span class="line">  .#&#123;<span class="variable">$B</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$currentSelector: #&#123;$currentSelector + "." + $B + $element-separator + $unit + ","&#125;;</span></span><br><span class="line"><span class="comment">$currentSelector: #&#123;.el-alert__content,&#125;;</span></span><br><span class="line"><span class="comment">hitAllSpecialNestRule 判断父级选择器是否包含'--','is',':'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@mixin</span> e(<span class="variable">$element</span>) &#123;</span><br><span class="line">  <span class="variable">$E</span>: <span class="variable">$element</span> !global;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$currentSelector</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$unit</span> in <span class="variable">$element</span> &#123;</span><br><span class="line">    <span class="variable">$currentSelector</span>: #&#123;<span class="variable">$currentSelector</span> + <span class="string">"."</span> + <span class="variable">$B</span> + <span class="variable">$element-separator</span> + <span class="variable">$unit</span> + <span class="string">","</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@if</span> hitAllSpecialNestRule(<span class="variable">$selector</span>) &#123;</span><br><span class="line">    <span class="keyword">@at-root</span> &#123;</span><br><span class="line">      #&#123;<span class="variable">$selector</span>&#125; &#123;</span><br><span class="line">        #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">          <span class="keyword">@content</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@at-root</span> &#123;</span><br><span class="line">      #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">@content</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修饰符</span></span><br><span class="line"><span class="comment">$currentSelector: #&#123;$currentSelector + &amp; + $modifier-separator + $unit + ","&#125;;</span></span><br><span class="line"><span class="comment">$currentSelector: #&#123;&amp;--success,&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@mixin</span> m(<span class="variable">$modifier</span>) &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$currentSelector</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$unit</span> in <span class="variable">$modifier</span> &#123;</span><br><span class="line">    <span class="variable">$currentSelector</span>: #&#123;<span class="variable">$currentSelector</span> + &amp; + <span class="variable">$modifier-separator</span> + <span class="variable">$unit</span> + <span class="string">","</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> configurable-m(<span class="variable">$modifier</span>, <span class="variable">$E-flag</span>: false) &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$interpolation</span>: <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$E-flag</span> &#123;</span><br><span class="line">    <span class="variable">$interpolation</span>: <span class="variable">$element-separator</span> + <span class="variable">$E-flag</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125; &#123;</span><br><span class="line">      .#&#123;<span class="variable">$B</span>+<span class="variable">$interpolation</span>+<span class="variable">$modifier-separator</span>+<span class="variable">$modifier</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">@content</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> spec-selector(<span class="variable">$specSelector</span>: <span class="string">''</span>, <span class="variable">$element</span>: <span class="variable">$E</span>, <span class="variable">$modifier</span>: false, <span class="variable">$block</span>: <span class="variable">$B</span>) &#123;</span><br><span class="line">  <span class="variable">$modifierCombo</span>: <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$modifier</span> &#123;</span><br><span class="line">    <span class="variable">$modifierCombo</span>: <span class="variable">$modifier-separator</span> + <span class="variable">$modifier</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;&amp;&#125;#&#123;<span class="variable">$specSelector</span>&#125;.#&#123;<span class="variable">$block</span>+<span class="variable">$element-separator</span>+<span class="variable">$element</span>+<span class="variable">$modifierCombo</span>&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> meb(<span class="variable">$modifier</span>: false, <span class="variable">$element</span>: <span class="variable">$E</span>, <span class="variable">$block</span>: <span class="variable">$B</span>) &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$modifierCombo</span>: <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$modifier</span> &#123;</span><br><span class="line">    <span class="variable">$modifierCombo</span>: <span class="variable">$modifier-separator</span> + <span class="variable">$modifier</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125; &#123;</span><br><span class="line">      .#&#123;<span class="variable">$block</span>+<span class="variable">$element-separator</span>+<span class="variable">$element</span>+<span class="variable">$modifierCombo</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">@content</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">添加 is- 修饰符*/</span><br><span class="line"><span class="keyword">@mixin</span> when(<span class="variable">$state</span>) &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    &amp;.#&#123;<span class="variable">$state-prefix</span> + <span class="variable">$state</span>&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> extend-rule(<span class="variable">$name</span>) &#123;</span><br><span class="line">  @extend #&#123;'%shared-'+$name&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> share-rule(<span class="variable">$name</span>) &#123;</span><br><span class="line">  <span class="variable">$rule-name</span>: <span class="string">'%shared-'</span>+<span class="variable">$name</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> #&#123;<span class="variable">$rule-name</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">@content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> pseudo(<span class="variable">$pseudo</span>) &#123;</span><br><span class="line">  @at-root #&#123;&amp;&#125;#&#123;':#&#123;$pseudo&#125;'&#125; &#123;</span><br><span class="line">    <span class="keyword">@content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="element中样式用到的命令"><a href="#element中样式用到的命令" class="headerlink" title="element中样式用到的命令"></a>element中样式用到的命令</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">node build/bin/iconInit.js</span><br><span class="line">"build:theme": "</span><br><span class="line">    node build/bin/gen-cssfile &amp;&amp; </span><br><span class="line">    gulp build --gulpfile packages/theme-chalk/gulpfile.js &amp;&amp; //    gulp打包</span><br><span class="line">    cp-cli packages/theme-chalk/lib lib/theme-chalk"    //  复制到根目录lib下</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  build/bin/iconInit.js</span></span><br><span class="line"><span class="comment">//  生成图标json文件</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">'postcss'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> fontFile = fs.readFileSync(path.resolve(__dirname, <span class="string">'../../packages/theme-chalk/src/icon.scss'</span>), <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">var</span> nodes = postcss.parse(fontFile).nodes;</span><br><span class="line"><span class="keyword">var</span> classList = [];</span><br><span class="line"></span><br><span class="line">nodes.forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> selector = node.selector || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/\.el-icon-([^:]+):before/</span>);</span><br><span class="line">  <span class="keyword">var</span> arr = selector.match(reg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr &amp;&amp; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">    classList.push(arr[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">classList.reverse(); <span class="comment">// 希望按 css 文件顺序倒序排列</span></span><br><span class="line"></span><br><span class="line">fs.writeFile(path.resolve(__dirname, <span class="string">'../../examples/icon.json'</span>), <span class="built_in">JSON</span>.stringify(classList), () =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  build/bin/gen-cssfile</span></span><br><span class="line"><span class="comment">//  将组件单独样式汇总生成package/theme-chalk/src/index.scss</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> Components = <span class="built_in">require</span>(<span class="string">'../../components.json'</span>);</span><br><span class="line"><span class="keyword">var</span> themes = [</span><br><span class="line">  <span class="string">'theme-chalk'</span></span><br><span class="line">];</span><br><span class="line">Components = <span class="built_in">Object</span>.keys(Components);</span><br><span class="line"><span class="keyword">var</span> basepath = path.resolve(__dirname, <span class="string">'../../packages/'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileExists</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.statSync(filePath).isFile();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">themes.forEach(<span class="function">(<span class="params">theme</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> isSCSS = theme !== <span class="string">'theme-default'</span>;</span><br><span class="line">  <span class="keyword">var</span> indexContent = isSCSS ? <span class="string">'@import "./base.scss";\n'</span> : <span class="string">'@import "./base.css";\n'</span>;</span><br><span class="line">  Components.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">'icon'</span>, <span class="string">'option'</span>, <span class="string">'option-group'</span>].indexOf(key) &gt; <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> fileName = key + (isSCSS ? <span class="string">'.scss'</span> : <span class="string">'.css'</span>);</span><br><span class="line">    indexContent += <span class="string">'@import "./'</span> + fileName + <span class="string">'";\n'</span>;</span><br><span class="line">    <span class="keyword">var</span> filePath = path.resolve(basepath, theme, <span class="string">'src'</span>, fileName);</span><br><span class="line">    <span class="keyword">if</span> (!fileExists(filePath)) &#123;</span><br><span class="line">      fs.writeFileSync(filePath, <span class="string">''</span>, <span class="string">'utf8'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(theme, <span class="string">' 创建遗漏的 '</span>, fileName, <span class="string">' 文件'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  fs.writeFileSync(path.resolve(basepath, theme, <span class="string">'src'</span>, isSCSS ? <span class="string">'index.scss'</span> : <span class="string">'index.css'</span>), indexContent);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>element源码</category>
        <category>element的样式管理</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>glup/rollup/webpack对比</title>
    <url>/2020/10/09/webpack-glup-rollup%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>gulp是一个基于流的概念简化任务之间的输入输出，特点是速度快。常用与JS/css压缩，less/sass转换。</p>
<p>webpack是一种模块化解决方案，是一种预编译模块方案，支持esmodule、cmd、umd规范。</p>
<p>Rollup对es6支持好，对amd,cmd并不支持需要引入插件，引入了tree-shaking使得打包体积更小。但没有webpack功能强大，不支持热更新。若你项目只需要打包出一个简单的bundle包，并是基于ES6模块开发的，可以考虑使用Rollup。<br>用一句话概括就是：在开发应用时使用 Webpack，开发库时使用 Rollup。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2020/08/21/vue%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期" title="生命周期"></p>
<ol>
<li><p><strong>beforecreate</strong>: 完成实例初始化，初始化非响应式变量，this指向创建的实例；<br>可以在这加个loading事件；<strong>data computed watch methods</strong>上的方法和数据均不能访问</p>
</li>
<li><p><strong>created</strong>: 实例创建完成，完成数据(Inject 、Provide 、 props 、methods 、data 、computed 和 watch)的初始化 导入依赖项。 未挂载DOM，不能访问$el，$ref为空数组。<br>可在这结束loading，还可以做一些初始化，可进行一些请求，请求不易过多，避免白屏时间太长。<br>若在此阶段进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中</p>
</li>
<li><p><strong>berofeMount</strong>: 有了el,编译了template|/outerHTML。能找到对应的template,并编译成render函数。</p>
</li>
<li><p><strong>mounted</strong>: 完成创建vm.$el，和双向绑定（实例化Wathcer），完成挂载DOM 和渲染;可在mounted钩子对挂载的dom进行操作。<br>即有了DOM 且完成了双向绑定 可访问DOM节点,$ref。可在这发起后端请求，拿回数据，配合路由钩子做一些事情；</p>
</li>
<li><p><strong>beforeUpdate</strong>: 数据更新之前。可在更新前访问现有的DOM,如手动移除添加的事件监听器；</p>
</li>
<li><p><strong>updated</strong>: 完成虚拟DOM的重新渲染和打补丁(检测当前的Watcher列表，是否存在需要更新的watcher，如有执行updated)；<br>注意：不要在此函数中操作数据，会陷入死循环的。</p>
</li>
<li><p><strong>activated</strong>:<br>在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了，<br>如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发</p>
</li>
<li><p><strong>deactivated</strong>: for keep-alive 组件被移除时使用</p>
</li>
<li><p><strong>beforeDestroy</strong>: 在执行app.$destroy()之前可做一些删除提示，如：你确认删除XX吗？可用于销毁定时器，解绑全局时间 销毁插件对象</p>
</li>
<li><p><strong>destroyed</strong>: 当前组件已被删除，销毁监听事件 组件 事件 子实例也被销毁.<br>这时组件已经没有了，你无法操作里面的任何东西了。</p>
</li>
</ol>
<p><a href="https://juejin.im/post/6844903780736040973#heading-3" target="_blank" rel="noopener">https://juejin.im/post/6844903780736040973#heading-3</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue生命周期</category>
      </categories>
      <tags>
        <tag>vue基础</tag>
        <tag>vue生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中央事件总线问题</title>
    <url>/2020/07/06/vue%E4%B8%AD%E5%A4%AE%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>业务场景，需要在兄弟组件之间传值，选择了中央事件总线解决办法，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    bus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  brother-a.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; bus &#125; <span class="keyword">from</span> <span class="string">'bus.js'</span></span><br><span class="line">bus.$emit(<span class="string">'action'</span>, val)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  brother-b.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; bus &#125; <span class="keyword">from</span> <span class="string">'bus.js'</span></span><br><span class="line">bus.$on(<span class="string">'action'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="comment">//  ...do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是实际使用过程中发现问题 <code>brother-b.vue</code> 中没有监听到值</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为 b 组件是动态生成的，此时没有 $on，无法监听到事件，也就是说</p>
<p><strong>在$emit时，必须已经$on，否则将无法监听到事件，对组件是有一定的同时存在的要求的</strong></p>
<p><strong><em>为什么会这样呢？</em></strong></p>
<p>中央事件总线的原理 是以一个Vue实例为桥梁，通过调用其$emit, $on事件实现组件的通信</p>
<p>查看Vue $emit源码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  vue 2.6.2</span></span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> lowerCaseEvent = event.toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">          tip(</span><br><span class="line">            <span class="string">"Event \""</span> + lowerCaseEvent + <span class="string">"\" is emitted in component "</span> +</span><br><span class="line">            (formatComponentName(vm)) + <span class="string">" but the handler is registered for \""</span> + event + <span class="string">"\". "</span> +</span><br><span class="line">            <span class="string">"Note that HTML attributes are case-insensitive and you cannot use "</span> +</span><br><span class="line">            <span class="string">"v-on to listen to camelCase events when using in-DOM templates. "</span> +</span><br><span class="line">            <span class="string">"You should probably use \""</span> + (hyphenate(event)) + <span class="string">"\" instead of \""</span> + event + <span class="string">"\"."</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这一步会获取 所有的监听函数，并执行</span></span><br><span class="line">      <span class="keyword">var</span> cbs = vm._events[event];</span><br><span class="line">      <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">        cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs;</span><br><span class="line">        <span class="keyword">var</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> info = <span class="string">"event handler for \""</span> + event + <span class="string">"\""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">          invokeWithErrorHandling(cbs[i], vm, args, vm, info);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 emit 的时候会获取回调函数并执行，此时如果没有on监听函数，当新的组件生成on函数也就不被监听了也不会执行。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>可以使用Vuex</li>
<li>将 a 组件的值<code>this.$emit()</code>传到了 父组件 ， 在从父组件通过<code>props</code>传值到 b 组件</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>中央事件总线</category>
      </categories>
      <tags>
        <tag>vue基础</tag>
        <tag>vue 传值问题</tag>
      </tags>
  </entry>
  <entry>
    <title>tree-shaking</title>
    <url>/2020/08/03/webpack%E4%B9%8Btree-shaking/</url>
    <content><![CDATA[<p>起源于 rollup, 目前webpack也可以使用<br>tree-shaking用来删除无用的代码</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。<br>分析程序流，判断哪些变量未被使用、引用，进而删除此代码。</p>
<h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><ul>
<li>虽然生产模式下默认开启，但是由于经过 babel 编译全部模块被封装成 IIFE(立即执行函数) 。IIFE 存在副作用无法被 tree-shaking 掉</li>
<li>需要配置 { module: false }(告诉babel不要编译模块代码，保留export/import语法)和 sideEffects: false</li>
<li>rollup 和 webpack 的 shaking 程度不同，以一个 Class 为例子</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.webpackjs.com/guides/tree-shaking/" target="_blank" rel="noopener">https://www.webpackjs.com/guides/tree-shaking/</a><br><a href="https://zhuanlan.zhihu.com/p/32831172" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32831172</a><br><a href="https://juejin.im/post/6844903544756109319" target="_blank" rel="noopener">https://juejin.im/post/6844903544756109319</a></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码</title>
    <url>/2020/11/16/webpack%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack源码</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack详解</title>
    <url>/2020/08/30/webpack%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="webpack作用"><a href="#webpack作用" class="headerlink" title="webpack作用"></a>webpack作用</h1><p>代码转换<br>文件优化<br>代码分割<br>模块合并<br>自动刷新<br>代码校验<br>自动发布</p>
<h1 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h1><p>（1）初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>（2）开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，通过执行对象的 run 方法开始执行编译；<br>（3）确定入口：根据配置中的 entry 找出所有入口文件；<br>（4）编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>（5）完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容及它们之间的依赖关系；<br>（6）输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会；<br>（7）输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中；</p>
<h1 id="loader与plugin的区别"><a href="#loader与plugin的区别" class="headerlink" title="loader与plugin的区别"></a>loader与plugin的区别</h1><p>loader，它是一个转换器，文件内容进行翻译，，比如将es6转换为es5，单纯的文件转换过程<br>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后。webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，并且执行相对应的任务</p>
<h1 id="如何优化webpack配置"><a href="#如何优化webpack配置" class="headerlink" title="如何优化webpack配置"></a>如何优化webpack配置</h1><h2 id="缩小文件查找范围"><a href="#缩小文件查找范围" class="headerlink" title="缩小文件查找范围"></a>缩小文件查找范围</h2><p>优化loader<br>优化resolve.modules<br>优化resolve.mainFields<br>优化resolve.alias<br>优化resolve.extensions<br>优化module.noPaese</p>
<h2 id="使用DllPlugin"><a href="#使用DllPlugin" class="headerlink" title="使用DllPlugin"></a>使用DllPlugin</h2><p>基础模块抽离，打包到动态链接库<br>需要使用模块，直接去动态链接库查找</p>
<h2 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h2><p>单线程变多进程</p>
<h3 id="HappyPack的原理"><a href="#HappyPack的原理" class="headerlink" title="HappyPack的原理"></a>HappyPack的原理</h3><p>webpack中最耗时的就是loader的转换过程，转换的流程很长。happypack的原理就是把这部分的任务拆解成多个子进程去并行处理，减少构建时间。<br>通过new HappyPack()实例化，然后把任务交由实例统一调度分配。核心调度器会将一个个任务分配给空闲的子进程。处理完毕后发送给核心调度器。</p>
<h2 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h2><p>开启多进程压缩代码，并行执行</p>
<h2 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h2><p>静态资源放到CDN服务器上面</p>
<h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>剔除无用的代码</p>
<h2 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h2><p>防止相同资源重复加载<br>减少网络流量及服务器成本</p>
<h2 id="使用prepack"><a href="#使用prepack" class="headerlink" title="使用prepack"></a>使用prepack</h2><p>编译代码时提前计算结果放到编译后的结果中，而不是在代码运行才求值</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack优化</title>
    <url>/2020/11/17/webpack%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>webpack优化有两个方向优化开发体验、优化输出质量</p>
<h1 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h1><h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><h3 id="缩小文件搜索范围"><a href="#缩小文件搜索范围" class="headerlink" title="缩小文件搜索范围"></a>缩小文件搜索范围</h3><ol>
<li>让尽可能少的文件被loader处理。优化正则 ，优化搜索文件范围。</li>
<li>优化 resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。</li>
<li>优化 resolve.mainFields </li>
<li>优化 resolve.alias通过别名来把原导入路径映射成一个新的导入路径</li>
<li>优化 resolve.extensions 配置。自动带上后缀后去尝试询问文件是否存在</li>
</ol>
<h3 id="使用DllPlugin"><a href="#使用DllPlugin" class="headerlink" title="使用DllPlugin"></a>使用DllPlugin</h3><p>动态链接库。配合DllReferencePlugin使用</p>
<p>执行构建时流程如下：</p>
<ol>
<li>如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。</li>
<li>在确保动态链接库存在时，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。</li>
</ol>
<h3 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h3><p>多线程</p>
<h3 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h3><p>多线程压缩</p>
<h2 id="优化开发体验-1"><a href="#优化开发体验-1" class="headerlink" title="优化开发体验"></a>优化开发体验</h2><h3 id="开启自动刷新"><a href="#开启自动刷新" class="headerlink" title="开启自动刷新"></a>开启自动刷新</h3><p>在配置文件 webpack.config.js 中设置 watch: true。<br>或者在执行启动 Webpack 命令时，带上 –watch 参数，完整命令是 webpack –watch。</p>
<h3 id="开启模块热更替"><a href="#开启模块热更替" class="headerlink" title="开启模块热更替"></a>开启模块热更替</h3><p>模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接 DevServer 和网页， 不同在于模块热替换独特的模块替换机制。</p>
<h1 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h1><h2 id="减少用户能感知到的加载时间"><a href="#减少用户能感知到的加载时间" class="headerlink" title="减少用户能感知到的加载时间"></a>减少用户能感知到的加载时间</h2><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>GZIP，UglifyJS，cssnano</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>配置publicPath</p>
<h3 id="TreeSharking"><a href="#TreeSharking" class="headerlink" title="TreeSharking"></a>TreeSharking</h3><h3 id="提取-公共代码"><a href="#提取-公共代码" class="headerlink" title="提取 公共代码"></a>提取 公共代码</h3><p>CommonsChunkPlugin</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CommonsChunkPlugin(&#123;</span><br><span class="line">  <span class="comment">// 从哪些 Chunk 中提取</span></span><br><span class="line">  chunks: [<span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">  <span class="comment">// 提取出的公共部分形成一个新的 Chunk，这个新 Chunk 的名称</span></span><br><span class="line">  name: <span class="string">'common'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><h2 id="提升流畅度"><a href="#提升流畅度" class="headerlink" title="提升流畅度"></a>提升流畅度</h2><h3 id="使用Prepack"><a href="#使用Prepack" class="headerlink" title="使用Prepack"></a>使用Prepack</h3><p>Prepack 由 Facebook 开源，它采用较为激进的方法：在保持运行结果一致的情况下，改变源代码的运行逻辑，输出性能更高的 JavaScript 代码。 实际上 Prepack 就是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。</p>
<p>Prepack 的工作原理和流程大致如下：</p>
<ol>
<li>通过 Babel 把 JavaScript 源码解析成抽象语法树（AST），以方便更细粒度地分析源码；</li>
<li>Prepack 实现了一个 JavaScript 解释器，用于执行源码。借助这个解释器 Prepack 才能掌握源码具体是如何执行的，并把执行过程中的结果返回到输出中。</li>
</ol>
<h3 id="开启Scope-Hoising"><a href="#开启Scope-Hoising" class="headerlink" title="开启Scope Hoising"></a>开启Scope Hoising</h3><p>Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 “作用域提升”</p>
<p>Scope Hoisting 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。 因此只有那些被引用了一次的模块才能被合并<br>由于 Scope Hoisting 需要分析出模块之间的依赖关系，因此源码必须采用 ES6 模块化语句，不然它将无法生效。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack优化</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2020/08/25/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>在触发事件n秒后执行，如果n秒内再次触发，则在n秒后执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        clearTimeout(tiimeout)</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            method.apply(that, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适用情况："><a href="#适用情况：" class="headerlink" title="适用情况："></a>适用情况：</h2><ol>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ol>
<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>在固定n秒内只触发一次事件<br>两种实现方法：</p>
<ol>
<li>事件戳</li>
<li>定时器</li>
</ol>
<p>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行<br>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timestamp</span>(<span class="params">func, waitTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> now</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span>(now - previous &gt; waitTime) &#123;</span><br><span class="line">            func.apply(that, <span class="built_in">arguments</span>)</span><br><span class="line">            previous = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">func, waitTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(that, args)</span><br><span class="line">            &#125;, waitTime)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS优化</tag>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>发布订阅</title>
    <url>/2020/08/25/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>其实24种基本的设计模式中并没有发布订阅模式，他只是观察者模式的一个别称。</p>
<p>但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。</p>
<p>在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。</p>
<p>举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。</p>
<h1 id="与观察者模式的区别"><a href="#与观察者模式的区别" class="headerlink" title="与观察者模式的区别"></a>与观察者模式的区别</h1><p>发布订阅模式相比观察者模式多了个事件通道，事件通道作为调度中心，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>简单实现的发布订阅：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>发布订阅<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> pubsub = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">(myObject)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Storage for topics that can be broadcast 可以广播的主题的存储</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// or listened to 或者听</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> topics = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// A topic identifier 主题标识符</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> subUid = <span class="number">-1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Publish or broadcast events of interest 发布或广播感兴趣的事件</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// with a specific topic name and arguments  具有特定的主题名称和参数</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// such as the data to pass along 如数据传递</span></span></span><br><span class="line"><span class="actionscript">    myObject.publish = <span class="function"><span class="keyword">function</span><span class="params">(topic, args)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> subscribers = topics[topic];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = subscribers ? subscribers.length : <span class="number">0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">while</span> (len--) &#123;</span></span><br><span class="line">            subscribers[len].func(topic, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Subscribe to events of interest  订阅感兴趣的事件</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// with a specific topic name and a 具有特定的主题名称和</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// callback function, to be executed 回调函数，将被执行</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// when the topic/event is observed 当观察到主题/事件时</span></span></span><br><span class="line"><span class="actionscript">    myObject.subscribe = <span class="function"><span class="keyword">function</span><span class="params">(topic, func)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line">            topics[topic] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> token = (++subUid).toString();</span></span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            func: func</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> token;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Unsubscribe from a specific 取消订阅</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// topic, based on a tokenized reference 主题，基于标记化参考</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// to the subscription 订阅</span></span></span><br><span class="line"><span class="actionscript">    myObject.unsubscribe = <span class="function"><span class="keyword">function</span><span class="params">( token )</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> m <span class="keyword">in</span> topics) &#123;</span></span><br><span class="line">            if (topics[m]) &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, j = topics[m].length; i &lt; j; i++ ) &#123;</span></span><br><span class="line">                    if ( topics[m][i].token === token ) &#123;</span><br><span class="line">                        topics[m].splice( i, 1 );</span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> token;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;(pubsub));</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// A simple message logger that logs any topics and data received through our 一个简单的消息记录器，记录通过我们接收的任何主题和数据。</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// subscriber 用户</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> messageLogger = <span class="function"><span class="keyword">function</span> <span class="params">(topics, data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"Logging:"</span> + topics + <span class="string">": "</span> + data);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// Subscribers listen for topics they have subscribed to and 订阅者监听他们订阅的主题和</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// invoke a callback function (e.g messageLogger) once a new 调用一个新的回调函数（例如MasigelgGER）</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// notification is broadcast on that topic 这个主题广播通知</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> subscription = pubsub.subscribe(<span class="string">"inbox/newMessage"</span>, messageLogger);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// Publishers are in charge of publishing topics or notifications of 出版商负责出版主题或通知。</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// interest to the application. e.g: 对应用程序有兴趣。例如：</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">pubsub.publish(<span class="string">"inbox/newMessage"</span>, <span class="string">"hello world!"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// or</span></span></span><br><span class="line"><span class="actionscript">pubsub.publish(<span class="string">"inbox/newMessage"</span>, [<span class="string">"test"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// or</span></span></span><br><span class="line"><span class="actionscript">pubsub.publish(<span class="string">"inbox/newMessage"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">    sender: <span class="string">"hello@google.com"</span>,</span></span><br><span class="line"><span class="actionscript">    body: <span class="string">"Hey again!"</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// We can also unsubscribe if we no longer wish for our subscribers   如果我们不再希望我们的订户，我们也可以退订。</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// to be notified  被通知</span></span></span><br><span class="line">pubsub.unsubscribe(subscription);</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// Once unsubscribed, this for example won't result in our  一旦退订，这将不会导致我们的</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// messageLogger being executed as the subscriber is MasaGelgGER作为订阅服务器执行</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// no longer listening 不再听</span></span></span><br><span class="line"><span class="actionscript">pubsub.publish(<span class="string">"inbox/newMessage"</span>, <span class="string">"Hello! are you still there?"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Vue3的优化</title>
    <url>/2020/09/27/Vue3%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="语法API优化"><a href="#语法API优化" class="headerlink" title="语法API优化"></a>语法API优化</h1><h2 id="Vue3的合成型API（Composition-API）"><a href="#Vue3的合成型API（Composition-API）" class="headerlink" title="Vue3的合成型API（Composition API）"></a>Vue3的合成型API（Composition API）</h2><p>Vue2使用选项类型API（Options API）<br>Vue3使用合成型API（Composition API）</p>
<p><strong>Vue核心团队将Composition API描述为“一组基于功能的附加API，可以灵活地组合组件逻辑”。</strong></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   vue2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'form-element'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span> &#123;&#123; title &#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-model</span>=<span class="string">'username'</span> <span class="attr">placeholder</span>=<span class="string">'Username'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'password'</span> <span class="attr">v-model</span>=<span class="string">'password'</span> <span class="attr">placeholder</span>=<span class="string">'Password'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'login'</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Values: &#123;&#123; username + ' ' + password &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    title: <span class="built_in">String</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      username: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">      password: <span class="string">''</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'title: '</span> + <span class="keyword">this</span>.title)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    lowerCaseUsername () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="keyword">this</span>.username.toLowerCase()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    login () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$emit(<span class="string">'login'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        username: <span class="keyword">this</span>.username,</span></span><br><span class="line"><span class="actionscript">        password: <span class="keyword">this</span>.password</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E4%BB%80%E4%B9%88%E6%98%AF-composition-api" target="_blank" rel="noopener">vue Composition文档</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- vue3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'form-element'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span> &#123;&#123; state.title &#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-model</span>=<span class="string">'state.username'</span> <span class="attr">placeholder</span>=<span class="string">'Username'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'password'</span> <span class="attr">v-model</span>=<span class="string">'state.password'</span> <span class="attr">placeholder</span>=<span class="string">'Password'</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'login'</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Values: &#123;&#123; state.username + ' ' + state.password &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; reactive, onMounted, computed, ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    title: <span class="built_in">String</span></span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  <span class="comment">//    组件实例被创建时，初始化props的解析后立刻调用。在生命周期中，它是在 beforeCreate 之前。</span></span></span><br><span class="line"><span class="actionscript">  <span class="comment">//    第一个参数是props.第二个参数是 context 对象(attrs, emit, slots)，它代替了 vue2 中通过 this 进行一些操作。</span></span></span><br><span class="line">  setup (props, &#123; emit &#125;) &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> state = reactive(&#123;</span></span><br><span class="line"><span class="actionscript">      username: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">      password: <span class="string">''</span>,</span></span><br><span class="line">      users: []</span><br><span class="line"><span class="javascript">      lowerCaseUsername: computed(<span class="function"><span class="params">()</span> =&gt;</span> state.username.toLowerCase())</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    <span class="comment">//  关于生命周期钩子函数，如果在setup()使用，只需要导入 onXxxx(名字和原来vue2中的生命周期中名字一致)</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//  新增两个调试狗子onRenderTracked	onRenderTriggered</span></span></span><br><span class="line"><span class="javascript">    onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'title: '</span> + props.title)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> getUserRepositories = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line">      users.push(state.username)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在用户prop的响应式引用上设置一个侦听器</span></span></span><br><span class="line">    watch(state.username, getUserRepositories)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(counter.value)  <span class="comment">//  0</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">      emit(<span class="string">'login'</span>, &#123;</span></span><br><span class="line">        username: state.username,</span><br><span class="line">        password: state.password</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123; </span></span><br><span class="line">      login,</span><br><span class="line">      state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>setup</code>它只是一个函数，向模板返回属性和函数。就是这样。我们在这里声明所有的反应式属性、计算属性、watchers和生命周期钩子，然后返回它们，这样它们就可以在模板中使用。没有从setup函数中返回的东西将不能在模板中使用</p>
<h3 id="作用及意义"><a href="#作用及意义" class="headerlink" title="作用及意义"></a>作用及意义</h3><h4 id="1-优化逻辑组织"><a href="#1-优化逻辑组织" class="headerlink" title="1.优化逻辑组织"></a>1.优化逻辑组织</h4><p>Options API 的设计是按照 methods、computed、data、props 这些不同的选项分类，当组件小的时候，这种分类方式一目了然；但是在大型组件中，一个组件可能有多个逻辑关注点，当使用 Options API 的时候，每一个关注点都有自己的 Options，如果需要修改一个逻辑点关注点，就需要在单个文件中不断上下切换和寻找。<br>Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p>
<h4 id="2-优化逻辑复用"><a href="#2-优化逻辑复用" class="headerlink" title="2.优化逻辑复用"></a>2.优化逻辑复用</h4><p>当我们开发项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 Vue.js 2.x 中，我们通常会用 mixins 去复用逻辑</p>
<ol>
<li><p>mixin</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个使用混入对象的组件</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  mixins: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></span><br></pre></td></tr></table></figure>
<p>使用mixin最大的缺点是我们不知道到底在组件内加了什么，导致<strong>命名冲突</strong>和<strong>数据来源</strong>不清晰。。</p>
</li>
<li><p>solt插槽<br>solt虽然可以插入代码但是只能在标签内使用，局限性较大。</p>
</li>
</ol>
<p>使用合成API</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span> (<span class="params"></span>) </span>&#123; count.value++ &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    incrememt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  b.vue</span></span><br><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count, increment &#125; = useCounter()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件的更新"><a href="#组件的更新" class="headerlink" title="组件的更新"></a>组件的更新</h2><h3 id="teleport-组件"><a href="#teleport-组件" class="headerlink" title="teleport 组件"></a>teleport 组件</h3><p>teleport 组件它只是单纯的把定义在其内部的内容转移到目标元素中，在元素结构上不会产生多余的元素，当然也不会影响到组件树，它相当于透明的存在。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">ref</span>=<span class="string">"dialog"</span>&gt;</span><span class="tag">&lt;/<span class="name">Dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把 dialog 组件渲染的这部分 DOM 挂载到 body 下面，不会受到父级样式的影响。<br><strong>为什么要有这个组件？</strong><br>为了有更好的代码组织体验。比如：有时，组件模板的一部分在逻辑上属于此组件，但从技术角度来看(如：样式化需求），最好将模板的这一部分移动到 DOM 中的其他位置。例如我们常用的弹窗、悬浮框、全局提示。</p>
<h3 id="Suspense-异步组件"><a href="#Suspense-异步组件" class="headerlink" title="Suspense 异步组件"></a>Suspense 异步组件</h3><p>它会暂停你的组件渲染，在异步组件加载完成并完全渲染之前 suspense 会先显示 #fallback 插槽的内容 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Suspense&gt;</span><br><span class="line">  &lt;template &gt;</span><br><span class="line">    &lt;Suspended-component &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">  &lt;template #fallback&gt;</span><br><span class="line">    Loading...</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;Suspense&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模板指令更新"><a href="#模板指令更新" class="headerlink" title="模板指令更新"></a>模板指令更新</h2><ol>
<li>组件上 v-model 用法已更改<br>在 2.x 里，使用 v-model 等同于向组件传递一个 value 属性，同时监听一个 input 事件：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">"pageTitle"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是以下代码的简写： --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:value</span>=<span class="string">"pageTitle"</span> @<span class="attr">input</span>=<span class="string">"pageTitle = $event"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
Vue2只支持绑定一个值，绑定多个值需要使用v-bind.sync<br><code>&lt;ChildComponent :foo.sync=&quot;bar&quot;&gt;&lt;/ChildComponent&gt;</code><br><code>&lt;ChildComponent :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/ChildComponent&gt;</code><br>在3.x中<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ChildComponent v-model=<span class="string">"pageTitle"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是以下代码的简写</span></span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=<span class="string">"pageTitle"</span></span><br><span class="line">  @update:modelValue=<span class="string">"pageTitle = $event"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
要修改一个model的名称的话，现在我们可以给 v-model 传递一个 参数 以取代此前的 model 选项：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=<span class="string">"pageTitle"</span> /&gt;</span><br><span class="line"><span class="comment">//是以下代码的简写：</span></span><br><span class="line">&lt;ChildComponent :title=<span class="string">"pageTitle"</span> @update:title=<span class="string">"pageTitle = $event"</span> /&gt;</span><br></pre></td></tr></table></figure>
还支持自定义修饰符</li>
<li><code>&lt;template v-for&gt;</code> 和非 - <code>v-for</code> 节点上 <code>key</code> 用法已更改</li>
<li>在同一元素上使用的 v-if 和 v-for 优先级已更改。（3.x 版本中 v-if 总是优先于 v-for 生效。）</li>
<li>v-bind=”object” 现在排序敏感<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: 'blue' &#125;"</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>v-for 中的 ref 不再注册 ref 数组</li>
</ol>
<h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><ol>
<li>destroyed 生命周期选项被重命名为 unmounted</li>
<li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li>
<li>prop default 工厂函数不再有权访问 this 是上下文</li>
<li>自定义指令 API 已更改为与组件生命周期一致</li>
<li>data 应始终声明为函数（Vue2是可以写为object的）</li>
<li>来自 mixin 的 data 选项现在可简单地合并</li>
<li>attribute 强制策略已更改</li>
<li>一些过渡 class 被重命名</li>
<li>组建 watch 选项和实例方法 $watch 不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。</li>
<li><code>&lt;template&gt;</code> 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li>
<li>在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。</li>
</ol>
<h2 id="移除的-API"><a href="#移除的-API" class="headerlink" title="移除的 API"></a>移除的 API</h2><ol>
<li>keyCode 支持作为 v-on 的修饰符</li>
<li>$on，$off 和 $once 实例方法</li>
<li>过滤（filter）</li>
<li>内联模板 attribute</li>
<li>$destroy 实例方法。用户不应再手动管理单个 Vue 组件的生命周期。</li>
</ol>
<h1 id="源码优化"><a href="#源码优化" class="headerlink" title="源码优化"></a>源码优化</h1><h2 id="源码管理方式"><a href="#源码管理方式" class="headerlink" title="源码管理方式"></a>源码管理方式</h2><p>源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目标是提升自身代码可维护性。</p>
<p>Vue.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码）、platforms（平台专有代码）、server（服务端渲染的相关代码）、sfc（.vue 单文件解析相关代码）、shared（共享工具代码） 等目录：</p>
<p>而到了 Vue.js 3.0 ，整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中：</p>
<p>monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p>
<p>另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue.js 使用的，这样用户如果只想使用 Vue.js 3.0 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue.js，减小了引用包的体积大小，而 Vue.js 2 .x 是做不到这一点的。</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>重构 Vue2.0 的时候，使用了 Flow 工具，但是在 Vue.js 3.0 的时候抛弃 Flow 转而采用 TypeScript 重构了整个项目<br>原因主要是TypeScript提供了更好的类型检查，能支持复杂的类型推导；</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="源码体积优化"><a href="#源码体积优化" class="headerlink" title="源码体积优化"></a>源码体积优化</h2><ol>
<li><p>移除一些冷门的 feature（比如 filter、inline-template 等）；</p>
</li>
<li><p>在 Vue 3 中，全局和内部 API 都经过了重构, 加强对 tree-shaking 技术的支持，减少打包体积。<br> 如果在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就在webpack打包时会被标记，然后压缩阶段会利用例如 uglify-js、terser 等压缩工具真正地删除这些没有用到的代码。这样也就间接达到了减少项目引入的 Vue.js 包体积的目的。</p>
</li>
</ol>
<h2 id="数据劫持优化"><a href="#数据劫持优化" class="headerlink" title="数据劫持优化"></a>数据劫持优化</h2><p>Vue.js 1.x 和 Vue.js 2.x 内部都是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'a'</span>,&#123;</span><br><span class="line">  <span class="keyword">get</span>()&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>()&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法，但是对于用户来说，还是增加了一定的心智负担。<br>其次就是如果对象嵌套层级过多的话，如果要劫持内部属性的话就需要递归整个对象，对性能也有一部分影响。</p>
<h3 id="reactive-–-gt-Proxy"><a href="#reactive-–-gt-Proxy" class="headerlink" title="reactive –&gt; Proxy"></a>reactive –&gt; Proxy</h3><p>Vue.js 3.0 使用了 Proxy API 做数据劫持，主要通过 reactive 创建响应式数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; target.__v_isReadonly) &#123;</span><br><span class="line">     <span class="keyword">return</span> target</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(target, <span class="literal">false</span>, mutableHandlers, mutableCollectionHandlers)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="comment">// 目标必须是对象或数组类型</span></span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">'production'</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (target.__v_raw &amp;&amp; !(isReadonly &amp;&amp; target.__v_isReactive)) &#123;</span><br><span class="line">    <span class="comment">// target 已经是 Proxy 对象，直接返回</span></span><br><span class="line">    <span class="comment">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(target, isReadonly ? <span class="string">"__v_readonly"</span> <span class="comment">/* readonly */</span> : <span class="string">"__v_reactive"</span> <span class="comment">/* reactive */</span>)) &#123;</span><br><span class="line">    <span class="comment">// target 已经有对应的 Proxy 了</span></span><br><span class="line">    <span class="keyword">return</span> isReadonly ? target.__v_readonly : target.__v_reactive</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有在白名单里的数据类型才能变成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (!canObserve(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用 Proxy 创建响应式</span></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers)</span><br><span class="line">  <span class="comment">// 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了</span></span><br><span class="line">  def(target, isReadonly ? <span class="string">"__v_readonly"</span> <span class="comment">/* readonly */</span> : <span class="string">"__v_reactive"</span> <span class="comment">/* reactive */</span>, observed)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  其实就是劫持对象进行一些操作</span></span><br><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  <span class="keyword">get</span>,  //  访问对象属性会触发 <span class="keyword">get</span> 函数；</span><br><span class="line">  <span class="keyword">set</span>,  //  设置对象属性会触发 <span class="keyword">set</span> 函数；</span><br><span class="line">  deleteProperty, //  删除对象属性会触发 deleteProperty 函数；</span><br><span class="line">  has,  //  in 操作符会触发 has 函数；</span><br><span class="line">  ownKeys //通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = /*#__PURE__*/ createGetter()</span><br><span class="line"></span><br><span class="line">function createGetter(isReadonly = false) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">"__v_isReactive"</span> <span class="comment">/* isReactive */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_isReactive</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"__v_isReadonly"</span> <span class="comment">/* isReadonly */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"__v_raw"</span> <span class="comment">/* raw */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_raw</span></span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> targetIsArray = isArray(target)</span><br><span class="line">    <span class="comment">// arrayInstrumentations 包含对数组一些方法修改的函数</span></span><br><span class="line">    <span class="comment">//  如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数</span></span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    <span class="comment">// 内置 Symbol key 不需要依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(key) &amp;&amp; builtInSymbols.has(key) || key === <span class="string">'__proto__'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    !isReadonly &amp;&amp; track(target, <span class="string">"get"</span> <span class="comment">/* GET */</span>, key)</span><br><span class="line">    <span class="keyword">return</span> isObject(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ?</span><br><span class="line">        readonly(res)</span><br><span class="line">        <span class="comment">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class="line">        : reactive(res)</span><br><span class="line">      : res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line">[<span class="string">'includes'</span>, <span class="string">'indexOf'</span>, <span class="string">'lastIndexOf'</span>].forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  arrayInstrumentations[key] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class="line">    <span class="keyword">const</span> arr = toRaw(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      track(arr, <span class="string">"get"</span> <span class="comment">/* GET */</span>, i + <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">    <span class="keyword">if</span> (res === <span class="number">-1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class="line">      <span class="keyword">return</span> arr[key](...args.map(toRaw))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 是否应该收集依赖</span></span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 当前激活的 effect</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="comment">// 原始数据对象 map</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, type, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 每个 target 对应一个 depsMap</span></span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    <span class="comment">// 每个 key 对应一个 dep 集合</span></span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    <span class="comment">// 收集当前激活的 effect 作为依赖</span></span><br><span class="line">    <span class="comment">// 我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们收集的依赖就是数据变化后执行的副作用函数。</span></span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    <span class="comment">// 当前激活的 effect 收集 dep 集合作为依赖</span></span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = /*#__PURE__*/ createSetter()</span><br><span class="line"></span><br><span class="line">function createSetter(shallow = false) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: string | symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">    value: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">    receiver: object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        oldValue.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 原始数据对象 map</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, type, key, newValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 targetMap 拿到 target 对应的依赖集合</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 没有依赖，直接返回</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建运行的 effects 集合</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="comment">// 添加 effects 的函数</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        effects.add(effect)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// SET | ADD | DELETE 操作之一，添加对应的 effects</span></span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    add(depsMap.get(key))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调度执行</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接运行</span></span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历执行 effects</span></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="关于proxy"><a href="#关于proxy" class="headerlink" title="关于proxy"></a>关于proxy</h3><ol>
<li>由于它劫持的是整个对象，那么对于对象的属性的增加和删除都能检测到。</li>
<li>Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能</li>
</ol>
<h2 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h2><p>静态节点标记</p>
<p>它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破</p>
<h2 id="Slot的编译优化"><a href="#Slot的编译优化" class="headerlink" title="Slot的编译优化"></a>Slot的编译优化</h2><p>Vue2.x中，如果有一个组件传入了slot，那么每次父组件更新的时候，必定会强制使子组件update，造成性能的浪费。这是由于2.x中，组件的插槽会被当成组件的一个普通children，因此在2.x里面的处理就是只要一个component中传入了slot，那么如果父组件更新，必定会update子组件。<br>Vue3优化了Slot的生成，父子组件可以单独更新。将所有的slot统一编译一个函数，当我们要将一个slot传给子组件的时候，将这个函数传给子组件，而调用这个函数，是子组件的行为，所以依赖的变化，就成为了子组件的而不是父组件的，所以当依赖变动时，我们只需要重新渲染子组件，而不必再去渲染父组件了</p>
<h2 id="事件侦听函数的缓存优化"><a href="#事件侦听函数的缓存优化" class="headerlink" title="事件侦听函数的缓存优化"></a>事件侦听函数的缓存优化</h2><p>比如对onclick进行一个缓存处理，当第一次渲染的时候，因为不存在_cache[1]，所以vue会自动生成一个内联函数，给<code>cache[1]</code>赋值<code>_cache[1] = () =&gt; {}</code>，使我们能自动去调用组件上最新的onclick。在后续的更新中，我们只需要从缓存_cache[1]中去读取同一个函数即可，而既然是同一个函数，那也没有被更新的必要了，所以@click也会被看成静态的。<br>这种优化在要给组件传入一个函数时尤为明显，如果不使用事件监听缓存的话，那么在父组件更新的时候，子组件就会跟着更新。而通过事件监听缓存机制，我们传给子组件的函数，它会在调用时动态地去找到组件中最新的那个函数，不需要对子组件进行更新。</p>
<h2 id="ssr渲染优化"><a href="#ssr渲染优化" class="headerlink" title="ssr渲染优化"></a>ssr渲染优化</h2><p>在SSR渲染时，会在服务端尽可能地将静态部分处理为字符串返回。如果存在动态节点，也会竟可能放在字符串里面，动态数据编译成模板字符串推入。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>vue基础</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue虚拟dom</title>
    <url>/2020/08/03/Vue%E8%99%9A%E6%8B%9Fdom/</url>
    <content><![CDATA[<h1 id="虚拟DOM是什么？"><a href="#虚拟DOM是什么？" class="headerlink" title="虚拟DOM是什么？"></a>虚拟DOM是什么？</h1><p>本质就是一个JS对象描述DOM节点，可以理解为将dom节点抽象成一个对象。</p>
<h1 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h1><p>提供与真实DOM节点所对应的虚拟节点vnode<br>将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图</p>
<h2 id="Virtual-DOM优势"><a href="#Virtual-DOM优势" class="headerlink" title="Virtual DOM优势"></a>Virtual DOM优势</h2><ul>
<li><p>具备跨平台的优势<br>由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p>
</li>
<li><p>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。<br>因为DOM操作的执行速度远不如Javascript的运算速度快，因此，把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。</p>
</li>
</ul>
<ul>
<li>提升渲染性能<br>Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</li>
</ul>
<p>为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。我们通过patch 的核心—-diff 算法，找出本次DOM需要更新的节点来更新，其他的不更新。比如修改某个model 100次，从1加到100，那么有了Virtual DOM的缓存之后，只会把最后一次修改patch到view上。那diff 算法的实现过程是怎样的？</p>
<h1 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h1><p><img src="/images/vue/%E8%99%9A%E6%8B%9FDOM.png" alt="渲染过程" title="渲染过程"></p>
<p>调用链关系：数据更新、渲染组件等—&gt;调用<em>render()生成vnode—&gt;交给<em>update()函数更新,_update()函数有__patch</em></em>()方法，在里面进行虚拟Dom diff等更新实际dom。</p>
<ol>
<li>渲染函数：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。</li>
<li>VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。</li>
<li>patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch本身就有补丁、修补的意思，其实际作用是在现有DOM上进行修改来实现更新视图的目的。Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。</li>
</ol>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p><img src="/images/vue/diff.png" alt="diff" title="diff"></p>
<p>Vue的diff算法是基于snabbdom改造过来的，仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。</p>
<h3 id="diff-算法包括几个步骤："><a href="#diff-算法包括几个步骤：" class="headerlink" title="diff 算法包括几个步骤："></a>diff 算法包括几个步骤：</h3><ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了</li>
</ul>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>判断两节点是否值得比较，值得比较则执行patchVnode<br>不值得比较则用Vnode替换oldVnode</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode)) &#123; invokeDestroyHook(oldVnode); &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isInitialPatch = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> insertedVnodeQueue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">        <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">        isInitialPatch = <span class="literal">true</span>;</span><br><span class="line">        createElm(vnode, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// patch existing root node</span></span><br><span class="line">            patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">                <span class="comment">// mounting to a real element</span></span><br><span class="line">                <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">                <span class="comment">// a successful hydration.</span></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">                    oldVnode.removeAttribute(SSR_ATTR);</span><br><span class="line">                    hydrating = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        warn(</span><br><span class="line">                        <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                        <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                        <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                        <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                        <span class="string">'full client-side render.'</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">                <span class="comment">// create an empty node and replace it</span></span><br><span class="line">                oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// replacing existing element</span></span><br><span class="line">            <span class="keyword">var</span> oldElm = oldVnode.elm;</span><br><span class="line">            <span class="keyword">var</span> parentElm = nodeOps.parentNode(oldElm);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create new node</span></span><br><span class="line">            createElm(</span><br><span class="line">                vnode,</span><br><span class="line">                insertedVnodeQueue,</span><br><span class="line">                <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">                <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">                <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">                oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">                nodeOps.nextSibling(oldElm)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">                <span class="keyword">var</span> ancestor = vnode.parent;</span><br><span class="line">                <span class="keyword">var</span> patchable = isPatchable(vnode);</span><br><span class="line">                <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">                        cbs.destroy[i](ancestor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor.elm = vnode.elm;</span><br><span class="line">                    <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">1</span> = <span class="number">0</span>; i$<span class="number">1</span> &lt; cbs.create.length; ++i$<span class="number">1</span>) &#123;</span><br><span class="line">                        cbs.create[i$<span class="number">1</span>](emptyNode, ancestor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// #6513</span></span><br><span class="line">                        <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">                        <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></span><br><span class="line">                        <span class="keyword">var</span> insert = ancestor.data.hook.insert;</span><br><span class="line">                        <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                            <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">2</span> = <span class="number">1</span>; i$<span class="number">2</span> &lt; insert.fns.length; i$<span class="number">2</span>++) &#123;</span><br><span class="line">                                insert.fns[i$<span class="number">2</span>]();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        registerRef(ancestor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor = ancestor.parent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// destroy old node</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">                removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">                invokeDestroyHook(oldVnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sameVnode(oldVnode, vnode)2个节点的基本属性相同，那么就进入了2个节点的diff过程。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">            a.key === b.key &amp;&amp; (   <span class="comment">//如果a的key 等于b的key</span></span><br><span class="line">                (</span><br><span class="line">                    a.tag === b.tag &amp;&amp; <span class="comment">// 如果a的tag 等于b的tag</span></span><br><span class="line">                    a.isComment === b.isComment &amp;&amp; <span class="comment">// 如果a和b 都是注释节点</span></span><br><span class="line">                    isDef(a.data) === isDef(b.data) &amp;&amp; <span class="comment">//如果a.data 和 b.data 都定义后，是组件，或者是都含有tag属性</span></span><br><span class="line">                    sameInputType(a, b)   <span class="comment">//相同的输入类型。判断a和b的属性是否相同</span></span><br><span class="line">                ) || (</span><br><span class="line">                    isTrue(a.isAsyncPlaceholder) &amp;&amp; <span class="comment">//判断是否是异步的</span></span><br><span class="line">                    a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">                    isUndef(b.asyncFactory.error)</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实主要就是对children进行diff以决定该如何更新。</p>
<h4 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123; <span class="comment">//如果他们相等</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> elm = vnode.elm = oldVnode.elm; <span class="comment">//获取真实的dom</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">            hydrate(oldVnode.elm, vnode, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vnode.isAsyncPlaceholder = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reuse element for static trees.</span></span><br><span class="line">    <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">    <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">    <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），</span></span><br><span class="line"><span class="comment">      并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），</span></span><br><span class="line"><span class="comment">      那么只需要替换elm以及componentInstance即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">        isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">        vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">        ) &#123;</span><br><span class="line">        vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">var</span> data = vnode.data;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">        <span class="comment">/*i = data.hook.prepatch，如果存在的话，见"./create-component componentVNodeHooks"。*/</span></span><br><span class="line">        i(oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldCh = oldVnode.children;</span><br><span class="line">    <span class="keyword">var</span> ch = vnode.children;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">        <span class="comment">/*调用update回调以及update钩子*/</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123;</span><br><span class="line">            cbs.update[i](oldVnode, vnode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) &#123;</span><br><span class="line">            i(oldVnode, vnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果这个VNode节点没有text文本时*/</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">            <span class="comment">/*新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren*/</span></span><br><span class="line">            <span class="keyword">if</span> (oldCh !== ch) &#123;</span><br><span class="line">                updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">            <span class="comment">/*如果老节点没有子节点而新节点存在子节点，先清空elm的文本内容，然后为当前节点加入子节点*/</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">                nodeOps.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">            <span class="comment">/*当新节点没有子节点而老节点有子节点的时候，则移除所有ele的子节点*/</span></span><br><span class="line">            removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">            <span class="comment">/*当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以直接去除ele的文本*/</span></span><br><span class="line">            nodeOps.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        <span class="comment">/*当新老节点text不一样时，直接替换这段文本*/</span></span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*调用postpatch钩子*/</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) &#123;</span><br><span class="line">            i(oldVnode, vnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patchVnode的规则</p>
<ol>
<li>如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），那么只需要替换elm以及componentInstance即可（原地复用）。</li>
<li>新老节点均有children子节点且不同，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</li>
<li>如果只有新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</li>
<li>如果只有老节点有子节点，直接删除老节点的子节点。</li>
<li>当新老节点都无子节点的时候，只是文本的替换</li>
</ol>
<h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue,removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">var</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="keyword">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">    <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">    <span class="comment">// during leaving transitions</span></span><br><span class="line">    <span class="keyword">var</span> canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        checkDuplicateKeys(newCh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUndef(oldKeyToIdx)) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vnodeToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果是oldS和newEndIdx匹配上了，那么真实dom中的第一个节点会移到最后</p>
</li>
<li><p>如果是oldE和newStartIdx匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</p>
</li>
<li><p>如果四种匹配没有一对是成功的，分为两种情况</p>
<ul>
<li>如果新旧子节点都存在key，那么会根据oldChild的key生成一张hash表，用newStartIdx的key与hash表做匹配，匹配成功就判断newStartIdx和匹配节点是否为sameNode，如果是，就在真实dom中将成功的节点移到最前面，否则，将S生成对应的节点插入到dom中对应的oldS位置，newStartIdx指针向中间移动，被匹配old中的节点置为null。</li>
<li>如果没有key,则直接将newStartIdx生成新的节点插入真实DOM（ps：这下可以解释为什么v-for的时候需要设置key了，如果没有key那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了）</li>
</ul>
</li>
</ul>
<h2 id="虚拟dom更快吗"><a href="#虚拟dom更快吗" class="headerlink" title="虚拟dom更快吗"></a>虚拟dom更快吗</h2><p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。</p>
<p>它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p>
<h2 id="为什么diff算法是O-n"><a href="#为什么diff算法是O-n" class="headerlink" title="为什么diff算法是O(n)?"></a>为什么diff算法是O(n)?</h2><p>正常的diff算法是O(n^3) 两颗树每个节点两两比对是O(n^2) ，在进行一次增删改就是O(n^3)<br>但Vue的diff算法是层级遍历，如果最外层节点不一样就认为没必要深入遍历了，如果一样然后在比对每一层级里面的节点</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/6844903923183157261" target="_blank" rel="noopener">https://juejin.im/post/6844903923183157261</a><br><a href="https://blog.fundebug.com/2019/06/26/vue-virtual-dom/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/06/26/vue-virtual-dom/</a><br><a href="https://juejin.im/post/6844903607913938951#heading-6" target="_blank" rel="noopener">https://juejin.im/post/6844903607913938951#heading-6</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>虚拟Dom,diff算法</category>
      </categories>
      <tags>
        <tag>vue基础</tag>
        <tag>虚拟DOM</tag>
        <tag>diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS知识整理</title>
    <url>/2019/08/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="window-onload和-document-ready-的区别，浏览器加载转圈结束时哪个时间点？"><a href="#window-onload和-document-ready-的区别，浏览器加载转圈结束时哪个时间点？" class="headerlink" title="window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？"></a>window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？</h2><p>window.onload是等到页面全都加载完才开始执行，且只能有一个window.onload,如果有多个只会执行最后一个<br>$(document).ready()等到DOM节点加载完开始执行</p>
<h2 id="setTimeout-和-setInterval-区别，如何互相实现？"><a href="#setTimeout-和-setInterval-区别，如何互相实现？" class="headerlink" title="setTimeout 和 setInterval 区别，如何互相实现？"></a>setTimeout 和 setInterval 区别，如何互相实现？</h2><p>setTimeout是指在指定时间后执行setTimeout内方法，setInterval是指每过指定时间执行代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInter</span>(<span class="params">time, func</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func()</span><br><span class="line">        setInter()</span><br><span class="line">    &#125;, time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params">time, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> setInter = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func()</span><br><span class="line">        clearInterval(setInter)</span><br><span class="line">    &#125;, time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setTimeout和requestAnimationFrame区别"><a href="#setTimeout和requestAnimationFrame区别" class="headerlink" title="setTimeout和requestAnimationFrame区别"></a>setTimeout和requestAnimationFrame区别</h2><p>setTimeout是固定时间后执行，requestAnimationFrame是根据屏幕刷新频率来执行</p>
<h2 id="form表单当前页面无刷新提交-target-iframe；"><a href="#form表单当前页面无刷新提交-target-iframe；" class="headerlink" title="form表单当前页面无刷新提交?target iframe；"></a>form表单当前页面无刷新提交?target iframe；</h2><h2 id="闭包以及作用域"><a href="#闭包以及作用域" class="headerlink" title="闭包以及作用域"></a>闭包以及作用域</h2><p>作用域是可访问变量的集合，可以分为全局作用域和局部作用域。</p>
<p>闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>this是在函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用</p>
<h2 id="JavaScript设计模式"><a href="#JavaScript设计模式" class="headerlink" title="JavaScript设计模式"></a>JavaScript设计模式</h2><p>单例模式<br>适配器模式<br>代理模式<br>发布-订阅模式<br>策略模式<br>迭代器模式  </p>
<h2 id="JSON-stringify深拷贝的缺点"><a href="#JSON-stringify深拷贝的缺点" class="headerlink" title="JSON.stringify深拷贝的缺点"></a>JSON.stringify深拷贝的缺点</h2><ol>
<li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</li>
<li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li>
<li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li>
<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li>
<li>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；</li>
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝</li>
</ol>
<h2 id="浏览器地址-输入URL后都发生了什么？"><a href="#浏览器地址-输入URL后都发生了什么？" class="headerlink" title="浏览器地址   输入URL后都发生了什么？"></a>浏览器地址   输入URL后都发生了什么？</h2><ol>
<li>解析URL地址得到IP地址：dns解析</li>
<li>客户端拿到IP地址进行tcp连接：三次握手</li>
<li>连接成功后发送HTTP请求：请求行、请求头、请求体</li>
<li>服务器处理并响应请求：响应行，响应头、响应体</li>
<li>浏览器解析渲染页面：构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</li>
<li>连接结束：这是tcp连接不会马上关闭因为HTTP1.1设置了keep-alive为true，标签关闭时会结束tcp连接四次挥手</li>
</ol>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="HTML方面能够结合各个浏览器api描述常用类库的实现。"><a href="#HTML方面能够结合各个浏览器api描述常用类库的实现。" class="headerlink" title="HTML方面能够结合各个浏览器api描述常用类库的实现。"></a>HTML方面能够结合各个浏览器api描述常用类库的实现。</h2><h2 id="css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理"><a href="#css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理" class="headerlink" title="css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理"></a>css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理</h2><h2 id="margin坍塌"><a href="#margin坍塌" class="headerlink" title="margin坍塌"></a>margin坍塌</h2><p>就是当两个兄弟块元素同时有margin-top和margin-bottom时，两个块级元素上下间距变为其中最大值，而不是两个值相加的值，水平方向不会出现这样的情况</p>
<h2 id="伪类和伪元素区别"><a href="#伪类和伪元素区别" class="headerlink" title="伪类和伪元素区别"></a>伪类和伪元素区别</h2><p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。<br>还有像:first-letter, :first-line, ::before ::after</p>
<h2 id="CSS的继承属性（部分）"><a href="#CSS的继承属性（部分）" class="headerlink" title="CSS的继承属性（部分）"></a>CSS的继承属性（部分）</h2><p>font-size：设置字体的尺寸<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>text-shadow：设置文本阴影<br>line-height：行高<br>元素可见性：visibility<br>光标属性：cursor</p>
<h2 id="CSS权重计算"><a href="#CSS权重计算" class="headerlink" title="CSS权重计算"></a>CSS权重计算</h2><p>第一等级：代表内联样式，如style=””，权值为 1000<br>第二等级：代表id选择器，如#content，权值为100<br>第三等级：代表类，伪类和属性选择器，如.content，权值为10<br>第四等级：代表标签选择器和伪元素选择器，如div p，权值为1<br>注意：通用选择器（*），子选择器（&gt;），和相邻同胞选择器（+）并不在这个等级中，所以他们的权值为0</p>
<h2 id="CSS优化技巧"><a href="#CSS优化技巧" class="headerlink" title="CSS优化技巧"></a>CSS优化技巧</h2><p>合理使用选择器<br>减少DOM操作，减少重绘和重排<br>去除无效的选择器<br>文件压缩<br>异步加载文件<br>减少@import的使用</p>
<h2 id="px-em-rem-vh-vw"><a href="#px-em-rem-vh-vw" class="headerlink" title="px/em/rem/vh/vw"></a>px/em/rem/vh/vw</h2><p>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的<br>em是相对长度单位。相对于当前父元素的字体尺寸。如未设置，则相对于浏览器的默认字体尺寸<br>rem是CSS3新增的一个相对单位。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素<br>css3新单位，view width的简写，是指可视窗口的宽度。假如宽度是1200px的话。那10vw就是120px<br>css3新单位，view height的简写，是指可视窗口的高度。假如高度是1200px的话。那10vh就是120px</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>单行文本</p>
<ol>
<li>若元素是单行文本, 则可设置 line-height 等于父元素高度</li>
</ol>
<p>行内块级元素<br>2. 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央.</p>
<p>.parent::after, .son{<br>    display:inline-block;<br>    vertical-align:middle;<br>}<br>.parent::after{<br>    content:’’;<br>    height:100%;<br>}<br>元素高度不定<br>3. 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<p>优点</p>
<p>元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断.<br>缺点</p>
<p>IE6~7, 甚至IE8 beta中无效.<br>4. flex<br>5. 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);  </span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点</p>
<p>代码量少<br>缺点</p>
<p>IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. </p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等"><a href="#知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等" class="headerlink" title="知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等"></a>知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等</h2><h2 id="https握手"><a href="#https握手" class="headerlink" title="https握手"></a>https握手</h2><p>首先客户端发起请求到服务端，服务端处理后发送一个公钥给客户端<br>客户端进行验证公钥，看公钥是否有效和是否过期<br>客户端验证通过会产生随机值key，然后用公钥进行加密回传给服务端<br>服务端用私钥解密后获得客户端的随机值key<br>利用随机值key加密数据后传输给客户端<br>客户端利用key值进行解密数据<br>客户端获取真正的数据</p>
<h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><p>二进制分帧<br>多路复用<br>服务器推送<br>头部压缩</p>
<h2 id="ajax请求"><a href="#ajax请求" class="headerlink" title="ajax请求"></a>ajax请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=jun'</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getData'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'jun'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>


<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="单页面应用原理"><a href="#单页面应用原理" class="headerlink" title="单页面应用原理"></a>单页面应用原理</h2><p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站</p>
<h2 id="vue修饰符"><a href="#vue修饰符" class="headerlink" title="vue修饰符"></a>vue修饰符</h2><p>v-model</p>
<ol>
<li>.lazy</li>
<li>.trim</li>
<li>number<br>事件修饰符</li>
<li>.stop阻止事件冒泡</li>
<li>.prevent阻止事件默认行为</li>
<li>.once只执行一次</li>
<li>.native</li>
<li>.capture事件捕获</li>
<li>.passive 相当于onscroll事件整了一个.lazy修饰符</li>
</ol>
<p>v-bind</p>
<ol>
<li>.sync v-bind @update的语法糖</li>
<li>.camel驼峰</li>
</ol>
<h1 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a>工程化工具</h1><h2 id="知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。"><a href="#知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。" class="headerlink" title="知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。"></a>知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。</h2><h2 id="知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。"><a href="#知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。" class="headerlink" title="知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。"></a>知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。</h2><h2 id="能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。"><a href="#能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。" class="headerlink" title="能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。"></a>能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。</h2><h2 id="了解异步模块加载的实现原理，能口喷代码实现核心逻辑。"><a href="#了解异步模块加载的实现原理，能口喷代码实现核心逻辑。" class="headerlink" title="了解异步模块加载的实现原理，能口喷代码实现核心逻辑。"></a>了解异步模块加载的实现原理，能口喷代码实现核心逻辑。</h2><p>通过jsonp方式动态创建script标签异步加载对应 chunk，并缓存到 promise 的 resolve 中，并标记对应 chunk 已经加载<br><a href="https://juejin.im/post/6844904033681948686#heading-8" target="_blank" rel="noopener">https://juejin.im/post/6844904033681948686#heading-8</a></p>
<h2 id="webpack执行过程"><a href="#webpack执行过程" class="headerlink" title="webpack执行过程"></a>webpack执行过程</h2><ol>
<li>初始化参数：从配置文件(默认webpack.config.js)和shell语句中读取与合并参数，得出最终的参数</li>
<li>开始编译(compile)：用上一步得到的参数初始化Comiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译</li>
<li>确定入口：根据配置中的entry找出所有的入口文件</li>
<li>编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译,再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过处理</li>
<li>完成编译模块：经过第四步之后，得到了每个模块被翻译之后的最终内容以及他们之间的依赖关系</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会</li>
<li>输出完成：在确定好输出内容后，根据配置(webpack.config.js &amp;&amp; shell)确定输出的路径和文件名，将文件的内容写入文件系统中(fs)</li>
</ol>
<h2 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h2><p>打包时间速度优化：</p>
<ol>
<li>优化loader配置：优化文件搜索范围，缓存babel编译过的文件</li>
<li>HappyPack开启多线程打包</li>
<li>DllPlugin</li>
<li>优化resolve： alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径。extensions：减少后缀列表<h2 id="减少体积"><a href="#减少体积" class="headerlink" title="减少体积"></a>减少体积</h2></li>
<li>Tree Shaking</li>
<li>Scope Hoisting 尽可能的合并打包出来的模块打一个函数中去</li>
</ol>
<ol>
<li>按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能</li>
</ol>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>http层面：</p>
<ol>
<li>减少HTTP请求</li>
<li>使用http2</li>
<li>使用cdn</li>
<li>使用缓存</li>
<li>服务端渲染   </li>
</ol>
<p>css:</p>
<ol>
<li>使用icon，不会失真。还有一个优点是生成的文件特别小</li>
<li>图片优化，延迟加载降低图片质量</li>
<li>压缩文件</li>
<li>通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码</li>
<li>使用 requestAnimationFrame 来实现视觉变化</li>
<li>使用css3动画，降低css新选择器复杂性</li>
</ol>
<p>JS</p>
<ol>
<li>减少重拍重绘</li>
<li>时间代理</li>
<li>使用switch语法</li>
<li>开启多线程webworker</li>
</ol>
<p>L型输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i === arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                result.concat(arr[i])</span><br><span class="line">                arr.pop()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(arr[i].shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mianshi</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router详解</title>
    <url>/2020/08/30/vue-router%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>vue-router是Vue的官方插件库，用来管理路由</p>
<ol>
<li>Vue的单页面应用是基于路由和组件的，路由用于设定访问路径，和组件对应起来。</li>
</ol>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>vue-router 提供了三种运行模式：<br>● hash: 使用 URL hash 值来作路由。默认模式。<br>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。<br>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载。<br>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/..），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；<br>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。<br>但是这种方式需要后端配置对应的URL，不然访问会出现404</p>
<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>为了兼容其他环境，如node环境的模式。会判断是否有window对应的api</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在Vue里使用vue-router只要引入vue-router组件。然后使用<code>Vue.use()</code>方法就会调用vue-router里的install方法</p>
<h2 id="install方法"><a href="#install方法" class="headerlink" title="install方法"></a>install方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'./components/view'</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'./components/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="keyword">return</span></span><br><span class="line">  install.installed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="keyword">if</span> (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._routerRoot = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._routerRoot = (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._routerRoot) || <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(<span class="string">'RouterView'</span>, View)</span><br><span class="line">  Vue.component(<span class="string">'RouterLink'</span>, Link)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里使用了一个全局混入<code>Vue.mixin()</code>把<code>beforeCreate</code>和<code>destory</code>钩子函数注册到每一个函数中，然后会调用<code>init()</code>方法</li>
<li>然后注册<code>$router</code>和<code>$route</code>变量</li>
<li>然后注册<code>RouterView</code>和<code>RouterLink</code>组件</li>
</ol>
<h2 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h2><p>接下我们本应该来看<code>init</code>方法，但<code>init</code>方法定义在 <code>VueRouter</code> 类里面，所以在调用init之前必先实例化<code>VueRouter</code>。先来看看 VueRouter</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> install: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">static</span> version: string</span><br><span class="line">  <span class="keyword">static</span> isNavigationFailure: <span class="built_in">Function</span></span><br><span class="line">  <span class="keyword">static</span> NavigationFailureType: any</span><br><span class="line"></span><br><span class="line">  app: any</span><br><span class="line">  apps: <span class="built_in">Array</span>&lt;any&gt;</span><br><span class="line">  ready: boolean</span><br><span class="line">  readyCbs: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  options: RouterOptions</span><br><span class="line">  mode: string</span><br><span class="line">  history: HashHistory | HTML5History | AbstractHistory</span><br><span class="line">  matcher: Matcher</span><br><span class="line">  fallback: boolean</span><br><span class="line">  beforeHooks: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;</span><br><span class="line">  resolveHooks: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;</span><br><span class="line">  afterHooks: <span class="built_in">Array</span>&lt;?AfterNavigationHook&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (options: RouterOptions = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.app = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.apps = []</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.beforeHooks = []</span><br><span class="line">    <span class="keyword">this</span>.resolveHooks = []</span><br><span class="line">    <span class="keyword">this</span>.afterHooks = []</span><br><span class="line">    <span class="comment">// 创建 matcher 匹配函数</span></span><br><span class="line">    <span class="keyword">this</span>.matcher = createMatcher(options.routes || [], <span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 根据 mode 实例化具体的 History，默认为'hash'模式</span></span><br><span class="line">    <span class="keyword">var</span> mode = options.mode || <span class="string">'hash'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 supportsPushState 判断浏览器是否支持'history'模式</span></span><br><span class="line">    <span class="comment">// 如果设置的是'history'但是如果浏览器不支持的话，'history'模式会退回到'hash'模式</span></span><br><span class="line">    <span class="comment">// fallback 是当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。</span></span><br><span class="line">    <span class="keyword">this</span>.fallback =</span><br><span class="line">      mode === <span class="string">'history'</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fallback) &#123;</span><br><span class="line">      mode = <span class="string">'hash'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">      mode = <span class="string">'abstract'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mode = mode</span><br><span class="line">    <span class="comment">// 根据不同模式选择实例化对应的 History 类</span></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'history'</span>:</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>, options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'hash'</span>:</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>, options.base, <span class="keyword">this</span>.fallback)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'abstract'</span>:</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>, options.base)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看见在初始化的时候<code>this.matcher = createMatcher(options.routes || [], this)</code>执行了createMatcher方法</p>
<h3 id="createMatcher方法相关"><a href="#createMatcher方法相关" class="headerlink" title="createMatcher方法相关"></a>createMatcher方法相关</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Matcher = &#123;</span><br><span class="line">  match: <span class="function">(<span class="params">raw: RawLocation, current?: Route, redirectedFrom?: Location</span>) =&gt;</span> Route;</span><br><span class="line">  addRoutes: <span class="function">(<span class="params">routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  routes: Array&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  router: VueRouter</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span> (<span class="params">routes</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">match</span> (<span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">redirect</span> (<span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">alias</span> (<span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span> (<span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createMatcher(options.routes || [], this)</code> 接收两个参数 一个为路由参数如下，另一个是<code>new VueRouter()</code>的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li><code>createMatcher</code>首先执行的逻辑是 <code>const { pathList, pathMap, nameMap } = createRouteMap(routes)</code> 创建一个路由映射表，<code>createRouteMap</code> 的定义在 <code>src/create-route-map</code> 中：<br><code>createRouteMap</code> 函数的目标是把用户的路由配置转换成一张路由映射表，它包含 3 个部分，pathList 存储所有的 path，pathMap 表示一个 path 到 RouteRecord 的映射关系，而 nameMap 表示 name 到 RouteRecord 的映射关系。</li>
<li>暴露出<code>match</code> 和 <code>addRoutes</code> 方法</li>
</ol>
<h4 id="addRoutes-方法"><a href="#addRoutes-方法" class="headerlink" title="addRoutes 方法"></a>addRoutes 方法</h4><p>其的作用是动态添加路由配置，因为在实际开发中有些场景是不能提前把路由写死的，需要根据一些条件动态添加路由，所以 Vue-Router 也提供了这一接口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span> (<span class="params">routes</span>) </span>&#123;</span><br><span class="line">  createRouteMap(routes, pathList, pathMap, nameMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addRoutes 的方法十分简单，再次调用 createRouteMap 即可，传入新的 routes 配置，由于 pathList、pathMap、nameMap 都是引用类型，执行 addRoutes 后会修改它们的值。</p>
<h4 id="match-方法"><a href="#match-方法" class="headerlink" title="match 方法"></a>match 方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  raw: RawLocation,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentRoute?: Route,</span></span></span><br><span class="line"><span class="function"><span class="params">  redirectedFrom?: Location</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(raw, currentRoute, <span class="literal">false</span>, router)</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="keyword">const</span> record = nameMap[name]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      warn(record, <span class="string">`Route with name '<span class="subst">$&#123;name&#125;</span>' does not exist`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    <span class="keyword">const</span> paramNames = record.regex.keys</span><br><span class="line">      .filter(<span class="function"><span class="params">key</span> =&gt;</span> !key.optional)</span><br><span class="line">      .map(<span class="function"><span class="params">key</span> =&gt;</span> key.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> location.params !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      location.params = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; <span class="keyword">typeof</span> currentRoute.params === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> currentRoute.params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> location.params) &amp;&amp; paramNames.indexOf(key) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">          location.params[key] = currentRoute.params[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location.path = fillParams(record.path, location.params, <span class="string">`named route "<span class="subst">$&#123;name&#125;</span>"`</span>)</span><br><span class="line">    <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.path) &#123;</span><br><span class="line">    location.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pathList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = pathList[i]</span><br><span class="line">      <span class="keyword">const</span> record = pathMap[path]</span><br><span class="line">      <span class="keyword">if</span> (matchRoute(record.regex, location.path, location.params)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// no match</span></span><br><span class="line">  <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  record: ?RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">  location: Location,</span></span></span><br><span class="line"><span class="function"><span class="params">  redirectedFrom?: Location</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (record &amp;&amp; record.redirect) &#123;</span><br><span class="line">    <span class="keyword">return</span> redirect(record, redirectedFrom || location)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (record &amp;&amp; record.matchAs) &#123;</span><br><span class="line">    <span class="keyword">return</span> alias(record, location, record.matchAs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createRoute(record, location, redirectedFrom, router)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">redirect</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    record: RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">    location: Location</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> originalRedirect = record.redirect</span><br><span class="line">    <span class="keyword">let</span> redirect = <span class="keyword">typeof</span> originalRedirect === <span class="string">'function'</span></span><br><span class="line">      ? originalRedirect(createRoute(record, location, <span class="literal">null</span>, router))</span><br><span class="line">      : originalRedirect</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> redirect === <span class="string">'string'</span>) &#123;</span><br><span class="line">      redirect = &#123; <span class="attr">path</span>: redirect &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!redirect || <span class="keyword">typeof</span> redirect !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="literal">false</span>, <span class="string">`invalid redirect option: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(redirect)&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> re: <span class="built_in">Object</span> = redirect</span><br><span class="line">    <span class="keyword">const</span> &#123; name, path &#125; = re</span><br><span class="line">    <span class="keyword">let</span> &#123; query, hash, params &#125; = location</span><br><span class="line">    query = re.hasOwnProperty(<span class="string">'query'</span>) ? re.query : query</span><br><span class="line">    hash = re.hasOwnProperty(<span class="string">'hash'</span>) ? re.hash : hash</span><br><span class="line">    params = re.hasOwnProperty(<span class="string">'params'</span>) ? re.params : params</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      <span class="comment">// resolved named direct</span></span><br><span class="line">      <span class="keyword">const</span> targetRecord = nameMap[name]</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        assert(targetRecord, <span class="string">`redirect failed: named route "<span class="subst">$&#123;name&#125;</span>" not found.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> match(&#123;</span><br><span class="line">        _normalized: <span class="literal">true</span>,</span><br><span class="line">        name,</span><br><span class="line">        query,</span><br><span class="line">        hash,</span><br><span class="line">        params</span><br><span class="line">      &#125;, <span class="literal">undefined</span>, location)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path) &#123;</span><br><span class="line">      <span class="comment">// 1. resolve relative redirect</span></span><br><span class="line">      <span class="keyword">const</span> rawPath = resolveRecordPath(path, record)</span><br><span class="line">      <span class="comment">// 2. resolve params</span></span><br><span class="line">      <span class="keyword">const</span> resolvedPath = fillParams(rawPath, params, <span class="string">`redirect route with path "<span class="subst">$&#123;rawPath&#125;</span>"`</span>)</span><br><span class="line">      <span class="comment">// 3. rematch with existing query and hash</span></span><br><span class="line">      <span class="keyword">return</span> match(&#123;</span><br><span class="line">        _normalized: <span class="literal">true</span>,</span><br><span class="line">        path: resolvedPath,</span><br><span class="line">        query,</span><br><span class="line">        hash</span><br><span class="line">      &#125;, <span class="literal">undefined</span>, location)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="literal">false</span>, <span class="string">`invalid redirect option: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(redirect)&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alias</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  record: RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">  location: Location,</span></span></span><br><span class="line"><span class="function"><span class="params">  matchAs: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> aliasedPath = fillParams(matchAs, location.params, <span class="string">`aliased route with path "<span class="subst">$&#123;matchAs&#125;</span>"`</span>)</span><br><span class="line">  <span class="keyword">const</span> aliasedMatch = match(&#123;</span><br><span class="line">    _normalized: <span class="literal">true</span>,</span><br><span class="line">    path: aliasedPath</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (aliasedMatch) &#123;</span><br><span class="line">    <span class="keyword">const</span> matched = aliasedMatch.matched</span><br><span class="line">    <span class="keyword">const</span> aliasedRecord = matched[matched.length - <span class="number">1</span>]</span><br><span class="line">    location.params = aliasedMatch.params</span><br><span class="line">    <span class="keyword">return</span> _createRoute(aliasedRecord, location)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 方法接收 3 个参数，其中 raw 是 RawLocation 类型，它可以是一个 url 字符串，也可以是一个 Location 对象；currentRoute 是 Route 类型，它表示当前的路径；redirectedFrom 和重定向相关，这里先忽略。<br>match 方法返回的是一个路径，它的作用是根据传入的 raw 和当前的路径 currentRoute 计算出一个新的路径并返回。</p>
<h3 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      assert(</span><br><span class="line">        install.installed,</span><br><span class="line">        <span class="string">`not installed. Make sure to call \`Vue.use(VueRouter)\` `</span> +</span><br><span class="line">          <span class="string">`before creating root instance.`</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.apps.push(app)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up app destroyed handler</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/2639</span></span><br><span class="line">    app.$once(<span class="string">'hook:destroyed'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// clean out app from this.apps array once destroyed</span></span><br><span class="line">      <span class="keyword">const</span> index = <span class="keyword">this</span>.apps.indexOf(app)</span><br><span class="line">      <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) <span class="keyword">this</span>.apps.splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// ensure we still have a main app or null if no apps</span></span><br><span class="line">      <span class="comment">// we do not release the router so it can be reused</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.app === app) <span class="keyword">this</span>.app = <span class="keyword">this</span>.apps[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.app) <span class="keyword">this</span>.history.teardown()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main app previously initialized</span></span><br><span class="line">    <span class="comment">// return as we don't need to set up new history listener</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.app) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.app = app</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> history = <span class="keyword">this</span>.history</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History || history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">      <span class="keyword">const</span> handleInitialScroll = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = history.current</span><br><span class="line">        <span class="keyword">const</span> expectScroll = <span class="keyword">this</span>.options.scrollBehavior</span><br><span class="line">        <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">'fullPath'</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">          handleScroll(<span class="keyword">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> setupListeners = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">        handleInitialScroll(routeOrError)</span><br><span class="line">      &#125;</span><br><span class="line">      history.transitionTo(</span><br><span class="line">        history.getCurrentLocation(),</span><br><span class="line">        setupListeners,</span><br><span class="line">        setupListeners</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.apps.forEach(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">match (raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.matcher.match(raw, current, redirectedFrom)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> currentRoute (): ?Route &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.history &amp;&amp; <span class="keyword">this</span>.history.current</span><br><span class="line">&#125;</span><br><span class="line">beforeEach (fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> registerHook(<span class="keyword">this</span>.beforeHooks, fn)</span><br><span class="line">&#125;</span><br><span class="line">beforeResolve (fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> registerHook(<span class="keyword">this</span>.resolveHooks, fn)</span><br><span class="line">&#125;</span><br><span class="line">afterEach (fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> registerHook(<span class="keyword">this</span>.afterHooks, fn)</span><br><span class="line">&#125;</span><br><span class="line">onReady (cb: <span class="built_in">Function</span>, errorCb?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.history.onReady(cb, errorCb)</span><br><span class="line">&#125;</span><br><span class="line">onError (errorCb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.history.onError(errorCb)</span><br><span class="line">&#125;</span><br><span class="line">push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!onComplete &amp;&amp; !onAbort &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.history.push(location, resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(location, onComplete, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!onComplete &amp;&amp; !onAbort &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.history.replace(location, resolve, reject)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.replace(location, onComplete, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">go (n: number) &#123;</span><br><span class="line">  <span class="keyword">this</span>.history.go(n)</span><br><span class="line">&#125;</span><br><span class="line">back () &#123;</span><br><span class="line">  <span class="keyword">this</span>.go(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">forward () &#123;</span><br><span class="line">  <span class="keyword">this</span>.go(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">getMatchedComponents (to?: RawLocation | Route): <span class="built_in">Array</span>&lt;any&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> route: any = to</span><br><span class="line">    ? to.matched</span><br><span class="line">      ? to</span><br><span class="line">      : <span class="keyword">this</span>.resolve(to).route</span><br><span class="line">    : <span class="keyword">this</span>.currentRoute</span><br><span class="line">  <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [].concat.apply(</span><br><span class="line">    [],</span><br><span class="line">    route.matched.map(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(m.components).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.components[key]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resolve (</span><br><span class="line">  to: RawLocation,</span><br><span class="line">  current?: Route,</span><br><span class="line">  append?: boolean</span><br><span class="line">): &#123;</span><br><span class="line">  location: Location,</span><br><span class="line">  route: Route,</span><br><span class="line">  href: string,</span><br><span class="line">  <span class="comment">// for backwards compat</span></span><br><span class="line">  normalizedTo: Location,</span><br><span class="line">  resolved: Route</span><br><span class="line">&#125; &#123;</span><br><span class="line">  current = current || <span class="keyword">this</span>.history.current</span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(to, current, append, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">const</span> route = <span class="keyword">this</span>.match(location, current)</span><br><span class="line">  <span class="keyword">const</span> fullPath = route.redirectedFrom || route.fullPath</span><br><span class="line">  <span class="keyword">const</span> base = <span class="keyword">this</span>.history.base</span><br><span class="line">  <span class="keyword">const</span> href = createHref(base, fullPath, <span class="keyword">this</span>.mode)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    location,</span><br><span class="line">    route,</span><br><span class="line">    href,</span><br><span class="line">    <span class="comment">// for backwards compat</span></span><br><span class="line">    normalizedTo: location,</span><br><span class="line">    resolved: route</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">addRoutes (routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;) &#123;</span><br><span class="line">  <span class="keyword">this</span>.matcher.addRoutes(routes)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.history.current !== START) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.transitionTo(<span class="keyword">this</span>.history.getCurrentLocation())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要来看<code>init</code>方法: 根据history类型执行对应的方法。先定义了 <code>setupHashListener</code> 函数，接着执行了 <code>history.transitionTo</code> 方法</p>
<h2 id="transitionTo"><a href="#transitionTo" class="headerlink" title="transitionTo()"></a>transitionTo()</h2><p><code>transitionTo</code> 定义在 <code>src/history/base.js</code>中 <code>hashHistory</code>和<code>HTML5History</code>继承<code>base.js</code>的<code>transitionTo</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  router: Router</span><br><span class="line">  base: string</span><br><span class="line">  current: Route</span><br><span class="line">  pending: ?Route</span><br><span class="line">  cb: <span class="function">(<span class="params">r: Route</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  ready: boolean</span><br><span class="line">  readyCbs: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  readyErrorCbs: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  errorCbs: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  listeners: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span><br><span class="line">  cleanupListeners: <span class="built_in">Function</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// implemented by sub-classes</span></span><br><span class="line">  +go: <span class="function">(<span class="params">n: number</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  +push: <span class="function">(<span class="params">loc: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  +replace: (</span><br><span class="line">    loc: RawLocation,</span><br><span class="line">    onComplete?: <span class="built_in">Function</span>,</span><br><span class="line">    onAbort?: <span class="built_in">Function</span></span><br><span class="line">  ) =&gt; <span class="keyword">void</span></span><br><span class="line">  +ensureURL: <span class="function">(<span class="params">push?: boolean</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  +getCurrentLocation: <span class="function"><span class="params">()</span> =&gt;</span> string</span><br><span class="line">  +setupListeners: <span class="built_in">Function</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (router: Router, base: ?string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.router = router</span><br><span class="line">    <span class="keyword">this</span>.base = normalizeBase(base)</span><br><span class="line">    <span class="comment">// start with a route object that stands for "nowhere"</span></span><br><span class="line">    <span class="keyword">this</span>.current = START</span><br><span class="line">    <span class="keyword">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.ready = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.readyCbs = []</span><br><span class="line">    <span class="keyword">this</span>.readyErrorCbs = []</span><br><span class="line">    <span class="keyword">this</span>.errorCbs = []</span><br><span class="line">    <span class="keyword">this</span>.listeners = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen (cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onReady (cb: <span class="built_in">Function</span>, <span class="attr">errorCb</span>: ?<span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.ready) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readyCbs.push(cb)</span><br><span class="line">      <span class="keyword">if</span> (errorCb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.readyErrorCbs.push(errorCb)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onError (errorCb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.errorCbs.push(errorCb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  transitionTo (</span><br><span class="line">    location: RawLocation,</span><br><span class="line">    onComplete?: <span class="built_in">Function</span>,</span><br><span class="line">    onAbort?: <span class="built_in">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">let</span> route</span><br><span class="line">    <span class="comment">// catch redirect option https://github.com/vuejs/vue-router/issues/3201</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      route = <span class="keyword">this</span>.router.match(location, <span class="keyword">this</span>.current)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.errorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb(e)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// Exception should still be thrown</span></span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="keyword">this</span>.current</span><br><span class="line">    <span class="keyword">this</span>.confirmTransition(</span><br><span class="line">      route,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.updateRoute(route)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        <span class="keyword">this</span>.ensureURL()</span><br><span class="line">        <span class="keyword">this</span>.router.afterHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">          hook &amp;&amp; hook(route, prev)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fire ready cbs once</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.ready) &#123;</span><br><span class="line">          <span class="keyword">this</span>.ready = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">this</span>.readyCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb(route)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">          onAbort(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err &amp;&amp; !<span class="keyword">this</span>.ready) &#123;</span><br><span class="line">          <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">          <span class="comment">// because it's triggered by the redirection instead</span></span><br><span class="line">          <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">          <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">          <span class="keyword">if</span> (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ready = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.readyErrorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">              cb(err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  updateRoute (route: Route) &#123;</span><br><span class="line">    <span class="keyword">this</span>.current = route</span><br><span class="line">    <span class="keyword">this</span>.cb &amp;&amp; <span class="keyword">this</span>.cb(route)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transtionTo方法：</p>
<ol>
<li>首先会调用<code>route = this.router.match(location, this.current)</code>，也就是上面createMatcher类中的match方法匹配到目标路径</li>
<li>接下来会调用<code>confirmTransition</code>做真正的切换，然后会执行函数内的回调函数</li>
</ol>
<h3 id="confirmTransition"><a href="#confirmTransition" class="headerlink" title="confirmTransition"></a>confirmTransition</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">confirmTransition (route: Route, <span class="attr">onComplete</span>: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">  <span class="comment">//  首先定义了 abort 函数，然后判断如果满足计算后的 route 和 current 是相同路径的话，则直接调用 this.ensureUrl 和 abort。</span></span><br><span class="line">  <span class="keyword">const</span> current = <span class="keyword">this</span>.current</span><br><span class="line">  <span class="keyword">this</span>.pending = route</span><br><span class="line">  <span class="keyword">const</span> abort = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// changed after adding errors with</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span></span><br><span class="line">    <span class="comment">// redirect and aborted navigation would produce an err == null</span></span><br><span class="line">    <span class="keyword">if</span> (!isNavigationFailure(err) &amp;&amp; isError(err)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.errorCbs.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">          cb(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="literal">false</span>, <span class="string">'uncaught error during route navigation:'</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onAbort &amp;&amp; onAbort(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lastRouteIndex = route.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> lastCurrentIndex = current.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isSameRoute(route, current) &amp;&amp;</span><br><span class="line">    <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">    lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">    route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureURL()</span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  接着又根据 `this.current.matched` 和 `route.matched` 执行了 resolveQueue 方法解析出 3 个队列</span></span><br><span class="line">  <span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">    <span class="keyword">this</span>.current.matched,</span><br><span class="line">    route.matched</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">    <span class="comment">// in-component leave guards</span></span><br><span class="line">    extractLeaveGuards(deactivated),</span><br><span class="line">    <span class="comment">// global before hooks</span></span><br><span class="line">    <span class="keyword">this</span>.router.beforeHooks,</span><br><span class="line">    <span class="comment">// in-component update hooks</span></span><br><span class="line">    extractUpdateHooks(updated),</span><br><span class="line">    <span class="comment">// in-config enter guards</span></span><br><span class="line">    activated.map(<span class="function"><span class="params">m</span> =&gt;</span> m.beforeEnter),</span><br><span class="line">    <span class="comment">// async components</span></span><br><span class="line">    resolveAsyncComponents(activated)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      hook(route, current, (to: any) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">          <span class="keyword">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(createNavigationAbortedError(current, route))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> to === <span class="string">'string'</span> ||</span><br><span class="line">          (<span class="keyword">typeof</span> to === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> to.path === <span class="string">'string'</span> || <span class="keyword">typeof</span> to.name === <span class="string">'string'</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// next('/') or next(&#123; path: '/' &#125;) -&gt; redirect</span></span><br><span class="line">          abort(createNavigationRedirectedError(current, route))</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">'object'</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">            <span class="keyword">this</span>.replace(to)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.push(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">          next(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      abort(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  最后：官方的说法叫导航守卫，实际上就是发生在路由路径切换的时候，执行的一系列钩子函数。</span></span><br><span class="line">  runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">    <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line">    <span class="keyword">const</span> queue = enterGuards.concat(<span class="keyword">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(queue, iterator, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.pending = <span class="literal">null</span></span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.router.app) &#123;</span><br><span class="line">        <span class="keyword">this</span>.router.app.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          handleRouteEntered(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeBase</span> (<span class="params">base: ?string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inBrowser) &#123;</span><br><span class="line">      <span class="comment">// respect &lt;base&gt; tag</span></span><br><span class="line">      <span class="keyword">const</span> baseEl = <span class="built_in">document</span>.querySelector(<span class="string">'base'</span>)</span><br><span class="line">      base = (baseEl &amp;&amp; baseEl.getAttribute(<span class="string">'href'</span>)) || <span class="string">'/'</span></span><br><span class="line">      <span class="comment">// strip full URL origin</span></span><br><span class="line">      base = base.replace(<span class="regexp">/^https?:\/\/[^\/]+/</span>, <span class="string">''</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      base = <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// make sure there's the starting slash</span></span><br><span class="line">  <span class="keyword">if</span> (base.charAt(<span class="number">0</span>) !== <span class="string">'/'</span>) &#123;</span><br><span class="line">    base = <span class="string">'/'</span> + base</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// remove trailing slash</span></span><br><span class="line">  <span class="keyword">return</span> base.replace(<span class="regexp">/\/$/</span>, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveQueue</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Array&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  next: Array&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  updated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  activated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(current.length, next.length)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current[i] !== next[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    updated: next.slice(<span class="number">0</span>, i),</span><br><span class="line">    activated: next.slice(i),</span><br><span class="line">    deactivated: current.slice(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuards</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  records: Array&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  bind: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  reverse?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> guards = flatMapComponents(records, (def, instance, match, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> guard = extractGuard(def, name)</span><br><span class="line">    <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(guard)</span><br><span class="line">        ? guard.map(<span class="function"><span class="params">guard</span> =&gt;</span> bind(guard, instance, match, key))</span><br><span class="line">        : bind(guard, instance, match, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> flatten(reverse ? guards.reverse() : guards)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuard</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  def: Object | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">NavigationGuard</span> | <span class="title">Array</span>&lt;<span class="title">NavigationGuard</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> def !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// extend now so that global mixins are applied.</span></span><br><span class="line">    def = _Vue.extend(def)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> def.options[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractLeaveGuards</span> (<span class="params">deactivated: Array&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extractGuards(deactivated, <span class="string">'beforeRouteLeave'</span>, bindGuard, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractUpdateHooks</span> (<span class="params">updated: Array&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extractGuards(updated, <span class="string">'beforeRouteUpdate'</span>, bindGuard)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindGuard</span> (<span class="params">guard: NavigationGuard, instance: ?_Vue</span>): ?<span class="title">NavigationGuard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">boundRouteGuard</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> guard.apply(instance, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractEnterGuards</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  activated: Array&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extractGuards(</span><br><span class="line">    activated,</span><br><span class="line">    <span class="string">'beforeRouteEnter'</span>,</span><br><span class="line">    (guard, _, match, key) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> bindEnterGuard(guard, match, key)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEnterGuard</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  guard: NavigationGuard,</span></span></span><br><span class="line"><span class="function"><span class="params">  match: RouteRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">NavigationGuard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">routeEnterGuard</span> (<span class="params">to, from, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guard(to, <span class="keyword">from</span>, cb =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!match.enteredCbs[key]) &#123;</span><br><span class="line">          match.enteredCbs[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        match.enteredCbs[key].push(cb)</span><br><span class="line">      &#125;</span><br><span class="line">      next(cb)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li></li>
<li></li>
</ol>
<h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>在上面VueRouter实例的时候会判断是否支持HashHistory和HTML5History模式然后实例化。这里看一下这两种模式的源码</p>
<h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HashHistory</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (router: Router, base: ?string, fallback: boolean) &#123;</span><br><span class="line">    <span class="keyword">super</span>(router, base)</span><br><span class="line">    <span class="comment">// check history fallback deeplinking</span></span><br><span class="line">    <span class="keyword">if</span> (fallback &amp;&amp; checkFallback(<span class="keyword">this</span>.base)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureSlash()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is delayed until the app mounts</span></span><br><span class="line">  <span class="comment">// to avoid the hashchange listener being fired too early</span></span><br><span class="line">  setupListeners () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.current</span><br><span class="line">      <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.transitionTo(getHash(), route =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">          handleScroll(<span class="keyword">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">          replaceHash(route.fullPath)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventType = supportsPushState ? <span class="string">'popstate'</span> : <span class="string">'hashchange'</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(</span><br><span class="line">      eventType,</span><br><span class="line">      handleRoutingEvent</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.listeners.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      route =&gt; &#123;</span><br><span class="line">        pushHash(route.fullPath)</span><br><span class="line">        handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      route =&gt; &#123;</span><br><span class="line">        replaceHash(route.fullPath)</span><br><span class="line">        handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go (n: number) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureURL (push?: boolean) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="keyword">this</span>.current.fullPath</span><br><span class="line">    <span class="keyword">if</span> (getHash() !== current) &#123;</span><br><span class="line">      push ? pushHash(current) : replaceHash(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getCurrentLocation () &#123;</span><br><span class="line">    <span class="keyword">return</span> getHash()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFallback</span> (<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> location = getLocation(base)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\/#/</span>.test(location)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(cleanPath(base + <span class="string">'/#'</span> + location))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureSlash</span> (<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = getHash()</span><br><span class="line">  <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  replaceHash(<span class="string">'/'</span> + path)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getHash</span> (<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We can't use window.location.hash here because it's not</span></span><br><span class="line">  <span class="comment">// consistent across browsers - Firefox will pre-decode it!</span></span><br><span class="line">  <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> index = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  <span class="comment">// empty path</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  href = href.slice(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> href</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> i = href.indexOf(<span class="string">'#'</span>)</span><br><span class="line">  <span class="keyword">const</span> base = i &gt;= <span class="number">0</span> ? href.slice(<span class="number">0</span>, i) : href</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;base&#125;</span>#<span class="subst">$&#123;path&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHash</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    pushState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当路由变化时，调用<code>push/replace -&gt; tanstionTo -&gt; updateRoute -&gt; this.cb</code>方法，而<code>this.cb</code>方法是通过<code>History.listen(cb)</code>进行设置的，在init()中对其进行了设置：</p>
<h4 id="监听地址栏"><a href="#监听地址栏" class="headerlink" title="监听地址栏"></a>监听地址栏</h4><p>上面的VueRouter.push()和VueRouter.replace()是可以在vue组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现：<br>该方法设置监听了浏览器事件hashchange,调用的函数为replaceHash,即在浏览器地址栏中直接输入路由相当于代码调用了replace()方法。</p>
<h3 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type Router <span class="keyword">from</span> <span class="string">'../index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; History &#125; <span class="keyword">from</span> <span class="string">'./base'</span></span><br><span class="line"><span class="keyword">import</span> &#123; cleanPath &#125; <span class="keyword">from</span> <span class="string">'../util/path'</span></span><br><span class="line"><span class="keyword">import</span> &#123; START &#125; <span class="keyword">from</span> <span class="string">'../util/route'</span></span><br><span class="line"><span class="keyword">import</span> &#123; setupScroll, handleScroll &#125; <span class="keyword">from</span> <span class="string">'../util/scroll'</span></span><br><span class="line"><span class="keyword">import</span> &#123; pushState, replaceState, supportsPushState &#125; <span class="keyword">from</span> <span class="string">'../util/push-state'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HTML5History</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  _startLocation: string</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (router: Router, base: ?string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(router, base)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._startLocation = getLocation(<span class="keyword">this</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setupListeners () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.current</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Avoiding first `popstate` event dispatched in some browsers but first</span></span><br><span class="line">      <span class="comment">// history route not updated since async guard at the same time.</span></span><br><span class="line">      <span class="keyword">const</span> location = getLocation(<span class="keyword">this</span>.base)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.current === START &amp;&amp; location === <span class="keyword">this</span>._startLocation) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.transitionTo(location, route =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">          handleScroll(router, route, current, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, handleRoutingEvent)</span><br><span class="line">    <span class="keyword">this</span>.listeners.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'popstate'</span>, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go (n: number) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      pushState(cleanPath(<span class="keyword">this</span>.base + route.fullPath))</span><br><span class="line">      handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      replaceState(cleanPath(<span class="keyword">this</span>.base + route.fullPath))</span><br><span class="line">      handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ensureURL (push?: boolean) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getLocation(<span class="keyword">this</span>.base) !== <span class="keyword">this</span>.current.fullPath) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = cleanPath(<span class="keyword">this</span>.base + <span class="keyword">this</span>.current.fullPath)</span><br><span class="line">      push ? pushState(current) : replaceState(current)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getCurrentLocation (): string &#123;</span><br><span class="line">    <span class="keyword">return</span> getLocation(<span class="keyword">this</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span> (<span class="params">base: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  <span class="keyword">if</span> (base &amp;&amp; path.toLowerCase().indexOf(base.toLowerCase()) === <span class="number">0</span>) &#123;</span><br><span class="line">    path = path.slice(base.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (path || <span class="string">'/'</span>) + <span class="built_in">window</span>.location.search + <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span> (<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">    saveScrollPosition()</span><br><span class="line">    <span class="comment">// 加了 try...catch 是因为 Safari 有调用 pushState 100 次限制</span></span><br><span class="line">    <span class="comment">// 一旦达到就会抛出 DOM Exception 18 错误</span></span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">            <span class="comment">// replace 的话 key 还是当前的 key 没必要生成新的</span></span><br><span class="line">            history.replaceState(&#123; <span class="attr">key</span>: _key &#125;, <span class="string">''</span>, url)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重新生成 key</span></span><br><span class="line">            _key = genKey()</span><br><span class="line">            <span class="comment">// 带入新的 key 值</span></span><br><span class="line">            history.pushState(&#123; <span class="attr">key</span>: _key &#125;, <span class="string">''</span>, url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 达到限制了 则重新指定新的地址</span></span><br><span class="line">        <span class="built_in">window</span>.location[replace ? <span class="string">'replace'</span> : <span class="string">'assign'</span>](url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用 pushState 传入 replace 为 true</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">replaceState</span> (<span class="params">url?: string</span>) </span>&#123;</span><br><span class="line">    pushState(url, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/6844903612930326541" target="_blank" rel="noopener">https://juejin.im/post/6844903612930326541</a><br><a href="https://juejin.im/post/6844903695365177352" target="_blank" rel="noopener">https://juejin.im/post/6844903695365177352</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
        <tag>vue-router原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码之双向数据绑定</title>
    <url>/2020/08/02/Vue%E6%BA%90%E7%A0%81%E4%B9%8B%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="双向数据绑定方式"><a href="#双向数据绑定方式" class="headerlink" title="双向数据绑定方式"></a>双向数据绑定方式</h1><h2 id="发布订阅方式"><a href="#发布订阅方式" class="headerlink" title="发布订阅方式"></a>发布订阅方式</h2><p>一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)</p>
<h2 id="脏值检查"><a href="#脏值检查" class="headerlink" title="脏值检查"></a>脏值检查</h2><p>angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</p>
<ul>
<li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li>
<li>XHR响应事件 ( $http )</li>
<li>浏览器Location变更事件 ( $location )</li>
<li>Timer事件( timeout ,interval )</li>
<li>执行 digest() 或apply()</li>
</ul>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h1 id="Vue的双向绑定实现方式"><a href="#Vue的双向绑定实现方式" class="headerlink" title="Vue的双向绑定实现方式"></a>Vue的双向绑定实现方式</h1><p>首先实现一个observer类，用来监听数据并通知订阅者执行相应的回调函数<br>实现compile类，作用是解析指令，为每个指令对应节点绑定更新函数，添加监听数据的订阅者<br>watch类为observer和compile的桥梁，在自身实例化的时候向订阅器里添加自身</p>
<p><img src="/images/vue/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.jpeg" alt="双向绑定原理" title="双向绑定原理"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>双向绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-model</span>=<span class="string">"number"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-click</span>=<span class="string">"increment"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">myVue</span><span class="params">(options)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>._init(options);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//  初始化</span></span></span><br><span class="line"><span class="actionscript">    myVue.prototype._init = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$options = options;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$data = options.data;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$methods = options.methods;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//  对应上图Dep，订阅器</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>._binding = &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>._obverse(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>._complie(<span class="keyword">this</span>.$el);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    myVue.prototype._obverse = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> value;</span></span><br><span class="line">        for (key in obj) &#123;</span><br><span class="line">            if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>._binding[key] = &#123;</span></span><br><span class="line">                    _directives: []</span><br><span class="line">                &#125;;</span><br><span class="line">                value = obj[key];</span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>._obverse(value);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> binding = <span class="keyword">this</span>._binding[key];</span></span><br><span class="line"><span class="javascript">                <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.$data, key, &#123;</span></span><br><span class="line"><span class="actionscript">                    enumerable: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">                    configurable: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">`获取<span class="subst">$&#123;value&#125;</span>`</span>);</span></span><br><span class="line"><span class="actionscript">                        <span class="keyword">return</span> value;</span></span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="actionscript">                    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newVal)</span> </span>&#123;</span></span><br><span class="line">                        if (value !== newVal) &#123;</span><br><span class="line">                            value = newVal;</span><br><span class="line"><span class="actionscript">                            binding._directives.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span></span><br><span class="line">                                item.update();</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//  解析指令</span></span></span><br><span class="line"><span class="actionscript">    myVue.prototype._complie = <span class="function"><span class="keyword">function</span> <span class="params">(root)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> nodes = root.children;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> node = nodes[i];</span></span><br><span class="line">            if (node.children.length) &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>._complie(node);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">                node.onclick = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> _this.$methods[attrVal].bind(_this.$data);</span></span><br><span class="line">                &#125;)();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName == <span class="string">'INPUT'</span> || node.tagName == <span class="string">'TEXTAREA'</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//  双向绑定：添加事件</span></span></span><br><span class="line"><span class="actionscript">                node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span><span class="params">(key)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//  像订阅器里添加订阅者</span></span></span><br><span class="line"><span class="actionscript">                    _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="actionscript">                        <span class="string">'input'</span>,</span></span><br><span class="line">                        node,</span><br><span class="line">                        _this,</span><br><span class="line">                        attrVal,</span><br><span class="line"><span class="actionscript">                        <span class="string">'value'</span></span></span><br><span class="line">                    ));</span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">                        _this.$data[attrVal] = nodes[key].value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)(i));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>);</span></span><br><span class="line"><span class="actionscript">                _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="actionscript">                    <span class="string">'text'</span>,</span></span><br><span class="line">                    node,</span><br><span class="line">                    _this,</span><br><span class="line">                    attrVal,</span><br><span class="line"><span class="actionscript">                    <span class="string">'innerHTML'</span></span></span><br><span class="line">                ))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span><span class="params">(name, el, vm, exp, attr)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.name = name;         <span class="comment">//指令名称，例如文本节点，该值设为"text"</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.el = el;             <span class="comment">//指令对应的DOM元素</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.vm = vm;             <span class="comment">//指令所属myVue实例</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.exp = exp;           <span class="comment">//指令对应的值，本例如"number"</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.attr = attr;         <span class="comment">//绑定的属性值，本例为"innerHTML"</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.update();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> app = <span class="keyword">new</span> myVue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                number: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="actionscript">                increment: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.number ++;</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里跟Vue的源码写的还是有很多出入，像complie解析dom节点的指令这一块是很复杂而且是单封装成一个函数的，Vue还可以实现自定义指令等等这里都没有实现。observe劫持监听函数也是具体逻辑没这么简单，订阅器这里只是简单的写了一个_bindding = []， 实际也要复杂很多，</p>
<h1 id="源码里的双向数据绑定"><a href="#源码里的双向数据绑定" class="headerlink" title="源码里的双向数据绑定"></a>源码里的双向数据绑定</h1><p>首先，Vue会先初始化，调用_init()方法</p>
<h2 id="init"><a href="#init" class="headerlink" title="_init()"></a>_init()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">            warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123; <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm._uid = uid$<span class="number">3</span>++; <span class="comment">//id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startTag,  <span class="comment">//开始标签</span></span><br><span class="line">        endTag;  <span class="comment">//结束标签</span></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="comment">//浏览器性能监控</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        startTag = <span class="string">"vue-perf-start:"</span> + (vm._uid);</span><br><span class="line">        endTag = <span class="string">"vue-perf-end:"</span> + (vm._uid);</span><br><span class="line">        mark(startTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed 一个避免被观察到的标志</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// merge options 合并选项 参数</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123; <span class="comment">//判断是否是组件</span></span><br><span class="line">                <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">                <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">                <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">                <span class="comment">//优化内部组件实例化</span></span><br><span class="line">                <span class="comment">//因为动态选项合并非常慢，没有一个是内部组件选项需要特殊处理。</span></span><br><span class="line">                <span class="comment">//初始化内部组件</span></span><br><span class="line">        initInternalComponent(vm, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//合并参数 将两个对象合成一个对象 将父值对象和子值对象合并在一起，并且优先取值子值，如果没有则取子值</span></span><br><span class="line">        vm.$options = mergeOptions(</span><br><span class="line">            resolveConstructorOptions(vm.constructor), <span class="comment">//  //解析constructor上的options属性的</span></span><br><span class="line">            options || &#123;&#125;,</span><br><span class="line">            vm</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化 代理 监听</span></span><br><span class="line">        initProxy(vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self 暴露真实的self</span></span><br><span class="line">    vm._self = vm;</span><br><span class="line">    initLifecycle(vm); <span class="comment">//初始化生命周期 标志</span></span><br><span class="line">    initEvents(vm); <span class="comment">//初始化事件</span></span><br><span class="line">    initRender(vm); <span class="comment">// 初始化渲染</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>); <span class="comment">//触发beforeCreate钩子函数</span></span><br><span class="line">    initInjections(vm); <span class="comment">// resolve injections before data/props 在数据/道具之前解决注入问题 //初始化 inject</span></span><br><span class="line">    initState(vm);  <span class="comment">//    //初始化状态</span></span><br><span class="line">    initProvide(vm); <span class="comment">// resolve provide after data/props  解决后提供数据/道具  provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性，用于组件之间通信。</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>); <span class="comment">//触发created钩子函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="comment">//浏览器 性能监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        vm._name = formatComponentName(vm, <span class="literal">false</span>);</span><br><span class="line">        mark(endTag);</span><br><span class="line">        measure((<span class="string">"vue "</span> + (vm._name) + <span class="string">" init"</span>), startTag, endTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        <span class="comment">// Vue 的$mount()为手动挂载，</span></span><br><span class="line">        <span class="comment">// 在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上。</span></span><br><span class="line">        <span class="comment">// new Vue时，el和$mount并没有本质上的不同。</span></span><br><span class="line">        vm.$mount(vm.$options.el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中调用了<code>initState(vm)</code>方法</p>
<h2 id="initState-vm"><a href="#initState-vm" class="headerlink" title="initState(vm)"></a>initState(vm)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">    vm._watchers = []; <span class="comment">//初始化观察者队列</span></span><br><span class="line">    <span class="keyword">var</span> opts = vm.$options; <span class="comment">//初始化参数</span></span><br><span class="line">    <span class="comment">//判断是否有props属性，如果有则添加观察者</span></span><br><span class="line">    <span class="keyword">if</span> (opts.props) &#123;</span><br><span class="line">        <span class="comment">//初始化props 检验props 数据格式是否是规范的如果是规范的则添加到观察者队列中</span></span><br><span class="line">        initProps(vm, opts.props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.methods) &#123; <span class="comment">//事件</span></span><br><span class="line">        <span class="comment">//   初始化事件Methods 把事件 冒泡到 vm[key] 虚拟dom  最外层中</span></span><br><span class="line">        initMethods(vm, opts.methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.data) &#123; <span class="comment">//初始化数据</span></span><br><span class="line">        <span class="comment">// 初始化数据 获取options.data 的数据 将他们添加到 监听者中</span></span><br><span class="line">        initData(vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  判断value 是否有__ob__    实例化 dep对象,获取dep对象  为 value添加__ob__ 属性，把vm._data添加到观察者中  返回 new Observer 实例化的对象</span></span><br><span class="line">        observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opts.computed) &#123; <span class="comment">//计算属性</span></span><br><span class="line">        <span class="comment">//初始化计算属性 并且判断属性的key 是否 在 data ，将 计算属性的key 添加入监听者中</span></span><br><span class="line">        initComputed(vm, opts.computed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//options 中的 watch</span></span><br><span class="line">    <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">        <span class="comment">//初始化Watch</span></span><br><span class="line">        initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="initData-vm"><a href="#initData-vm" class="headerlink" title="initData(vm);"></a>initData(vm);</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化数据 获取options.data 的数据 将他们添加到 监听者中</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//获取到$options.data 数据</span></span><br><span class="line">        <span class="keyword">var</span> data = vm.$options.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取data中的数据   判断如果是函数则</span></span><br><span class="line">        data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> <span class="comment">//如果data是函数</span></span><br><span class="line">            ? getData(data, vm)  <span class="comment">//转换数据 如果数据是 一个函数的时候 执行该函数 拿到数据</span></span><br><span class="line">            : data || &#123;&#125;; <span class="comment">//直接获取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(data)) &#123; <span class="comment">//如果不是对象 则发出警告日志</span></span><br><span class="line">            data = &#123;&#125;;</span><br><span class="line">            <span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">                <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">                <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">                vm</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// proxy data on instance</span></span><br><span class="line">        <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data); <span class="comment">//获取数据的key</span></span><br><span class="line">        <span class="keyword">var</span> props = vm.$options.props; <span class="comment">//获取props 属性</span></span><br><span class="line">        <span class="keyword">var</span> methods = vm.$options.methods; <span class="comment">//获取事件</span></span><br><span class="line">        <span class="keyword">var</span> i = keys.length; <span class="comment">//获取数据key的长度</span></span><br><span class="line">        <span class="keyword">while</span> (i--) &#123; <span class="comment">//循环data</span></span><br><span class="line">            <span class="keyword">var</span> key = keys[i];</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123; <span class="comment">//如果数据中的 key 与事件 中的定义的key 一样 则发出警告</span></span><br><span class="line">                    warn(</span><br><span class="line">                        (<span class="string">"Method \""</span> + key + <span class="string">"\" has already been defined as a data property."</span>),</span><br><span class="line">                        vm</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123; <span class="comment">//如果数据中的 key 与props属性 中的定义的key 一样 则发出警告</span></span><br><span class="line">                <span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">                    <span class="string">"The data property \""</span> + key + <span class="string">"\" is already declared as a prop. "</span> +</span><br><span class="line">                    <span class="string">"Use prop default value instead."</span>,</span><br><span class="line">                    vm</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123; <span class="comment">//如果不是 以$或者_开头</span></span><br><span class="line">                <span class="built_in">console</span>.log(vm)</span><br><span class="line">                <span class="built_in">console</span>.log(key)</span><br><span class="line"></span><br><span class="line">                proxy(vm, <span class="string">"_data"</span>, key); <span class="comment">//把数据添加到监听者中</span></span><br><span class="line">                <span class="built_in">console</span>.log(vm)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// observe data</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">        observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里面我们主要看<code>observe(data, true);</code>方法</p>
<h2 id="observe-vm-data-true"><a href="#observe-vm-data-true" class="headerlink" title="observe(vm._data = {}, true)"></a>observe(vm._data = {}, true)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment">     * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment">     * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment">     *尝试为值创建一个观察者实例，</span></span><br><span class="line"><span class="comment">     *如果成功观察，返回新的观察者；</span></span><br><span class="line"><span class="comment">     *或现有的观察员，如果值已经有一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 判断value 是否有__ob__    实例化 dep对象,获取dep对象  为 value添加__ob__ 属性  返回 new Observer 实例化的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">        <span class="comment">//value 不是一个对象 或者 实例化 的VNode</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ob;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">        ob = value.__ob__;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        shouldObserve &amp;&amp;  <span class="comment">//shouldObserve 为真</span></span><br><span class="line">        !isServerRendering() &amp;&amp;  <span class="comment">//并且不是在服务器node环境下</span></span><br><span class="line">        (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp; <span class="comment">//是数组或者是对象</span></span><br><span class="line">        <span class="built_in">Object</span>.isExtensible(value) &amp;&amp; <span class="comment">//Object.preventExtensions(O) 方法用于锁住对象属性，使其不能够拓展，也就是不能增加新的属性，但是属性的值仍然可以更改，也可以把属性删除，Object.isExtensible用于判断对象是否可以被拓展</span></span><br><span class="line">        !value._isVue <span class="comment">//_isVue为假</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//实例化 dep对象 为 value添加__ob__ 属性</span></span><br><span class="line">        ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是RootData，即咱们在新建Vue实例时，传到data里的值，只有RootData在每次observe的时候，会进行计数。 vmCount是用来记录此Vue实例被使用的次数的， 比如，我们有一个组件logo，页面头部和尾部都需要展示logo，都用了这个组件，那么这个时候vmCount就会计数，值为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123; <span class="comment">//是根节点数据的话 并且 ob 存在</span></span><br><span class="line">        ob.vmCount++; <span class="comment">//统计有几个vm</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    * 实例化 dep对象,获取dep对象  为 value添加__ob__ 属性</span></span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会为value添加创建一个观察者也就是<code>new Observer(value);</code>，下面我们来看Observer函数</p>
<h2 id="Observer构造函数"><a href="#Observer构造函数" class="headerlink" title="Observer构造函数"></a>Observer构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attached to each observed</span></span><br><span class="line"><span class="comment"> * object. Once attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object's property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> * *每个观察到的观察者类</span></span><br><span class="line"><span class="comment"> *对象。一旦被连接，观察者就转换目标。</span></span><br><span class="line"><span class="comment"> *对象的属性键为吸收器/设置器</span></span><br><span class="line"><span class="comment"> *收集依赖关系并发送更新。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例化 dep对象,获取dep对象  为 value添加__ob__ 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置监听 value 必须是对象</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123; <span class="comment">//判断是不是数组</span></span><br><span class="line">        <span class="keyword">var</span> augment = hasProto  <span class="comment">//__proto__ 存在么 高级浏览器都会有这个</span></span><br><span class="line">            ? protoAugment</span><br><span class="line">            : copyAugment;</span><br><span class="line">        augment(value, arrayMethods, arrayKeys);</span><br><span class="line">        <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment"> * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment"> * value type is Object.</span></span><br><span class="line"><span class="comment"> * *遍历每个属性并将其转换为</span></span><br><span class="line"><span class="comment"> * getter / setter。此方法只应在调用时调用</span></span><br><span class="line"><span class="comment"> *值类型是Object。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        defineReactive(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> * 观察数组项的列表。</span></span><br><span class="line"><span class="comment"> * 把数组拆分一个个 添加到观察者 上面去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">        observe(items[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里Observer会判断value类型是否为数组，如果是数组的话会调用<code>observeArray</code>方法，拆分数组一个个重新调用observe方法。<br>否则的话就调用walk方法，会遍历对象每一个属性然后调用<code>defineReactive</code>方法</p>
<h2 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive()"></a>defineReactive()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> * 在对象上定义一个无功属性。</span></span><br><span class="line"><span class="comment"> * 更新数据</span></span><br><span class="line"><span class="comment"> * 通过defineProperty的set方法去通知notify()订阅者subscribers有新的值修改</span></span><br><span class="line"><span class="comment"> * 添加观察者 get set方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, <span class="regexp">//</span>对象</span></span></span><br><span class="line"><span class="function"><span class="params">                        key,<span class="regexp">//</span>对象的key</span></span></span><br><span class="line"><span class="function"><span class="params">                        val, <span class="regexp">//</span>监听的数据 返回的数据</span></span></span><br><span class="line"><span class="function"><span class="params">                        customSetter, <span class="regexp">//</span>  日志函数</span></span></span><br><span class="line"><span class="function"><span class="params">                        shallow <span class="regexp">//</span>是否要添加__ob__ 属性</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个主题对象，对象中有空的观察者列表</span></span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="comment">//获取描述属性</span></span><br><span class="line">    <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">    <span class="comment">//获取实力对象属性或者方法，包括定义的描述属性</span></span><br><span class="line">    <span class="keyword">var</span> _property = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">    <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getter &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">        val = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">    <span class="comment">//判断value 是否有__ob__    实例化 dep对象,获取dep对象  为 value添加__ob__ 属性递归把val添加到观察者中  返回 new Observer 实例化的对象</span></span><br><span class="line">    <span class="keyword">var</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">    <span class="comment">//定义描述</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">            <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;  <span class="comment">//Dep.target 静态标志 标志了Dep添加了Watcher 实例化的对象</span></span><br><span class="line">                <span class="comment">//添加一个dep</span></span><br><span class="line">                dep.depend();</span><br><span class="line">                <span class="keyword">if</span> (childOb) &#123;  <span class="comment">//如果子节点存在也添加一个dep</span></span><br><span class="line">                    childOb.dep.depend();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;  <span class="comment">//判断是否是数组 如果是数组</span></span><br><span class="line">                        dependArray(value);   <span class="comment">//则数组也添加dep</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">            <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">            <span class="comment">/* eslint-disable no-self-compare  新旧值比较 如果是一样则不执行了*/</span></span><br><span class="line">            <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* eslint-enable no-self-compare</span></span><br><span class="line"><span class="comment">             *   不是生产环境的情况下</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">                customSetter();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">                <span class="comment">//set 方法 设置新的值</span></span><br><span class="line">                setter.call(obj, newVal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//新的值直接给他</span></span><br><span class="line">                val = newVal;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//observe 添加 观察者</span></span><br><span class="line">            childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">            <span class="comment">//更新数据</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是双向绑定的核心–通过Object.defineProperty重写value的get,set，也就是读取和设置新值。</p>
<p>其中Dep可以理解为一个订阅器，</p>
<ol>
<li>在get是会判断是否有Dep.target从而调用dep.depend()。Dep.target是Watcher的实例</li>
<li>在set时会判断调用dep.notify()，为订阅器里的所有订阅者更新视图。</li>
</ol>
<p>下面是Dep的源码：</p>
<h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple dep是可观察到的，可以有多个</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.订阅它的指令。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//主题对象Dep构造函数  主要用于添加发布事件后，用户更新数据的 响应式原理之一函数</span></span><br><span class="line"><span class="keyword">var</span> Dep = <span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//uid  初始化为0</span></span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> <span class="title">addSub</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dep.prototype.removeSub = <span class="function"><span class="keyword">function</span> <span class="title">removeSub</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*删除 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//this$1.deps[i].depend();</span></span><br><span class="line"><span class="comment">//为Watcher 添加 为Watcher.newDeps.push(dep); 一个dep对象</span></span><br><span class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个dep    target 是Watcher dep就是dep对象</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">//像指令添加依赖项</span></span><br><span class="line">        Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">var</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里面有上面defineReactive调用比较重要的depend、notify方法。<br>依据Dep.target会调用depend方法。depend方法会调用<code>Dep.target.addDep(this);</code>方法，此方法调用<code>dep.addSub(this);</code>向订阅器添加了订阅者。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive. 向该指令添加依赖项。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = dep.id; <span class="comment">//dep.id 一个持续相加的id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;<span class="comment">//如果id存在</span></span><br><span class="line">        <span class="keyword">this</span>.newDepIds.add(id); <span class="comment">//添加一个id</span></span><br><span class="line">        <span class="keyword">this</span>.newDeps.push(dep); <span class="comment">//添加一个deps</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;  <span class="comment">//如果depIds 不存在id则添加一个addSub  //添加一个sub</span></span><br><span class="line">            dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，defineReactive内部的get会依据是否有Dep.target来向订阅器添加订阅者</p>
<p>那Dep.target到底是什么以及它的作用：<br>Dep.target是Watcher的实例，<br>了解作用之前我们看一下都在哪些地方调用了Dep.target?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> targetStack = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">_target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//target 是Watcher dep就是dep对象</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123; <span class="comment">//静态标志 Dep当前是否有添加了target</span></span><br><span class="line">        <span class="comment">//添加一个pushTarget</span></span><br><span class="line">        targetStack.push(Dep.target);</span><br><span class="line">    &#125;</span><br><span class="line">    Dep.target = _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出盏一个pushTarget</span></span><br><span class="line">    Dep.target = targetStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dep.target虽然是全局属性，但是被封装在上面这两个函数中<br>那又有什么地方调用了pushTarget呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  第一处</span></span><br><span class="line"><span class="comment">//触发钩子函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHook</span>(<span class="params">vm,  <span class="regexp">//</span>虚拟dom  vonde</span></span></span><br><span class="line"><span class="function"><span class="params">                hook <span class="regexp">//</span>钩子函数的key</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">    <span class="comment">//调用生命周期钩子时禁用dep集合</span></span><br><span class="line">    <span class="comment">//Dep.target = _target; //存储</span></span><br><span class="line">    pushTarget();</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    popTarget();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  第二处</span></span><br><span class="line"><span class="comment">//转换数据 如果数据是 一个函数的时候 执行该函数 拿到数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data, vm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">    <span class="comment">//调用数据getter时禁用dep收集</span></span><br><span class="line">    pushTarget();</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    popTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">     * 计算getter，并重新收集依赖项。 获取value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//添加一个dep target</span></span><br><span class="line">        pushTarget(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//  ...</span></span><br><span class="line">        popTarget();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>以上虽然有三处调用pushTarget，但实际只有一处有实际作用，第一二处Dep.target反而设置为空，没有发挥实际作用。而第三处是在Watcher类原型方法上调用的，我们来看看Watcher类</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> * *观察者分析表达式，收集依赖项，</span></span><br><span class="line"><span class="comment"> *并在表达式值更改时触发回调。</span></span><br><span class="line"><span class="comment"> *这用于$watch() api和指令。</span></span><br><span class="line"><span class="comment"> * 当前vue实例、updateComponent函数、空函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Watcher = <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, <span class="regexp">//</span>vm dom</span></span></span><br><span class="line"><span class="function"><span class="params">                                expOrFn,  <span class="regexp">//</span>获取值的函数，或者是更新viwe试图函数</span></span></span><br><span class="line"><span class="function"><span class="params">                                cb, <span class="regexp">//</span>回调函数,回调值给回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">                                options, <span class="regexp">//</span>参数</span></span></span><br><span class="line"><span class="function"><span class="params">                                isRenderWatcher<span class="regexp">//</span>是否渲染过得观察者</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//是否是已经渲染过得观察者</span></span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123; <span class="comment">//把当前 Watcher 对象赋值给 vm._watcher上</span></span><br><span class="line">        vm._watcher = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把观察者添加到队列里面 当前Watcher添加到vue实例上</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123; <span class="comment">//如果有参数</span></span><br><span class="line">        <span class="keyword">this</span>.deep = !!options.deep; <span class="comment">//实际</span></span><br><span class="line">        <span class="keyword">this</span>.user = !!options.user; <span class="comment">//用户</span></span><br><span class="line">        <span class="keyword">this</span>.lazy = !!options.lazy; <span class="comment">//懒惰 ssr 渲染</span></span><br><span class="line">        <span class="keyword">this</span>.sync = !!options.sync; <span class="comment">//如果是同步</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb; <span class="comment">//回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.id = ++uid$<span class="number">1</span>; <span class="comment">// uid for batching uid为批处理  监听者id</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span>; <span class="comment">//激活</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy; <span class="comment">// for lazy watchers 对于懒惰的观察者</span></span><br><span class="line">    <span class="keyword">this</span>.deps = [];    <span class="comment">// 观察者队列</span></span><br><span class="line">    <span class="keyword">this</span>.newDeps = []; <span class="comment">// 新的观察者队列</span></span><br><span class="line">    <span class="comment">// 内容不可重复的数组对象</span></span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> _Set();</span><br><span class="line">    <span class="comment">// 把函数变成字符串形式</span></span><br><span class="line">    <span class="keyword">this</span>.expression = expOrFn.toString();</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="comment">//getter的解析表达式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">//获取值的函数</span></span><br><span class="line">        <span class="keyword">this</span>.getter = expOrFn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是keepAlive 组件则会走这里</span></span><br><span class="line">        <span class="comment">//path 因该是路由地址</span></span><br><span class="line">        <span class="keyword">if</span> (bailRE.test(path)) &#123;  <span class="comment">//  匹配上 返回 true     var bailRE = /[^\w.$]/;  //匹配不是 数字字母下划线 $符号   开头的为true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// //匹配不上  path在已点分割</span></span><br><span class="line">            <span class="comment">// var segments = path.split('.');</span></span><br><span class="line">            <span class="comment">// return function (obj) &#123;</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//     for (var i = 0; i &lt; segments.length; i++) &#123;</span></span><br><span class="line">            <span class="comment">//         //如果有参数则返回真</span></span><br><span class="line">            <span class="comment">//         if (!obj) &#123;</span></span><br><span class="line">            <span class="comment">//             return</span></span><br><span class="line">            <span class="comment">//         &#125;</span></span><br><span class="line">            <span class="comment">//         //将对象中的一个key值 赋值给该对象 相当于 segments 以点拆分的数组做obj 的key</span></span><br><span class="line">            <span class="comment">//         obj = obj[segments[i]];</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     //否则返回一个对象</span></span><br><span class="line">            <span class="comment">//     return obj</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配不是 数字字母下划线 $符号   开头的为true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123; <span class="comment">//如果不存在 则给一个空的数组</span></span><br><span class="line">            <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">            <span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; </span><br><span class="line">            warn(<span class="string">"Failed watching path: \""</span> + expOrFn + <span class="string">"\" "</span> +</span><br><span class="line">                <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">                <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">                vm</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ?  <span class="comment">//   lazy为真的的时候才能获取值  这个有是组件才为真</span></span><br><span class="line">        <span class="literal">undefined</span> :</span><br><span class="line">        <span class="keyword">this</span>.get(); <span class="comment">//计算getter，并重新收集依赖项。 获取值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment"> * 计算getter，并重新收集依赖项。 获取value值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个dep target</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取值 如果报错 则执行catch</span></span><br><span class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">            handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">            <span class="comment">// dependencies for deep watching</span></span><br><span class="line">            <span class="comment">//“触摸”每个属性，以便它们都被跟踪为</span></span><br><span class="line">            <span class="comment">//依赖深度观察</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// //如果val 有__ob__ 属性</span></span><br><span class="line">                <span class="comment">// if (val.__ob__) &#123;</span></span><br><span class="line">                <span class="comment">//     var depId = val.__ob__.dep.id;</span></span><br><span class="line">                <span class="comment">//     // seen 中是否含有depId 属性或者方法</span></span><br><span class="line">                <span class="comment">//     if (seen.has(depId)) &#123;</span></span><br><span class="line">                <span class="comment">//         return</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">                <span class="comment">//     //如果没有则添加进去</span></span><br><span class="line">                <span class="comment">//     seen.add(depId);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//为 seenObjects 深度收集val 中的key</span></span><br><span class="line">                traverse(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出盏一个pushTarget</span></span><br><span class="line">            popTarget();</span><br><span class="line">            <span class="comment">//清理依赖项集合。</span></span><br><span class="line">            <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive. 向该指令添加依赖项。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span>(<span class="params">dep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = dep.id; <span class="comment">//dep.id 一个持续相加的id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;<span class="comment">//如果id存在</span></span><br><span class="line">        <span class="keyword">this</span>.newDepIds.add(id); <span class="comment">//添加一个id</span></span><br><span class="line">        <span class="keyword">this</span>.newDeps.push(dep); <span class="comment">//添加一个deps</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;  <span class="comment">//如果depIds 不存在id则添加一个addSub  //添加一个sub</span></span><br><span class="line">            dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment"> * 清理观察者依赖项集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.cleanupDeps = <span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span>$<span class="number">1</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">this</span>.deps.length; <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">var</span> dep = <span class="keyword">this</span>$<span class="number">1.</span>deps[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>$<span class="number">1.n</span>ewDepIds.has(dep.id)) &#123;</span><br><span class="line">            <span class="comment">//清除 sub</span></span><br><span class="line">            dep.removeSub(<span class="keyword">this</span>$<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">this</span>.depIds; <span class="comment">//获取depid</span></span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds; <span class="comment">//获取新的depids</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp;  <span class="comment">//旧的覆盖新的</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear(); <span class="comment">//清空对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//互换值</span></span><br><span class="line">    tmp = <span class="keyword">this</span>.deps; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps;</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp;</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscriber interface.用户界面。</span></span><br><span class="line"><span class="comment"> * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment"> * 将在依赖项更改时调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else  伊斯坦布尔忽略其他 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123; <span class="comment">//懒惰的 忽略</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123; <span class="comment">//如果是同步</span></span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是多个观察者</span></span><br><span class="line">        queueWatcher(<span class="keyword">this</span>); <span class="comment">//队列中的观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scheduler job interface. 调度器的工作界面。</span></span><br><span class="line"><span class="comment"> * Will be called by the scheduler. 将被调度程序调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123; <span class="comment">//活跃</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="keyword">this</span>.get(); <span class="comment">//获取值 函数 expOrFn</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            value !== <span class="keyword">this</span>.value ||  <span class="comment">//如果值不相等</span></span><br><span class="line">            <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even 深度观察和对象/数组上的观察应该是均匀的</span></span><br><span class="line">            <span class="comment">// when the value is the same, because the value may 当值相等时，因为值可以</span></span><br><span class="line">            <span class="comment">// have mutated. 有突变。</span></span><br><span class="line">            isObject(value) || <span class="comment">//或者值的object</span></span><br><span class="line">            <span class="keyword">this</span>.deep  <span class="comment">//获取deep为true</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// set new value</span></span><br><span class="line">            <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.value; <span class="comment">//获取旧的值</span></span><br><span class="line">            <span class="keyword">this</span>.value = value; <span class="comment">//新的值赋值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123; <span class="comment">//如果是user 用更新值</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue); <span class="comment">//更新回调函数  获取到新的值 和旧的值</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    handleError(e, <span class="keyword">this</span>.vm, (<span class="string">"callback for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue);<span class="comment">//更新回调函数  获取到新的值 和旧的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the value of the watcher. 评估观察者的值。</span></span><br><span class="line"><span class="comment"> * This only gets called for lazy watchers. 这只适用于懒惰的观察者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.evaluate = <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get(); <span class="comment">//获取值</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span>; <span class="comment">// 懒惰者标志  标志已经获取过一次值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment"> * 依赖于此监视程序收集的所有dep。</span></span><br><span class="line"><span class="comment"> * 循环deps 收集 newDeps dep 当newDeps 数据被清空的时候重新收集依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.newDeps.push(dep); //添加一个deps</span></span><br><span class="line">    <span class="comment">//deps=this.newDeps</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span>$<span class="number">1</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">this</span>.deps.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 为Watcher 添加dep 对象</span></span><br><span class="line">        <span class="comment">// this.newDeps.push(dep); //添加一个deps</span></span><br><span class="line">        <span class="keyword">this</span>$<span class="number">1.</span>deps[i].depend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment"> * 从所有依赖项的订阅方列表中删除self。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Watcher.prototype.teardown = <span class="function"><span class="keyword">function</span> <span class="title">teardown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span>$<span class="number">1</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        <span class="comment">// remove self from vm's watcher list 从vm的监视者列表中删除self</span></span><br><span class="line">        <span class="comment">// this is a somewhat expensive operation so we skip it 这是一个有点昂贵的操作，所以我们跳过它</span></span><br><span class="line">        <span class="comment">// if the vm is being destroyed. 如果vm被销毁。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123; <span class="comment">//是否销毁的标志</span></span><br><span class="line">            remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>); <span class="comment">//删除观察者</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">this</span>.deps.length;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="comment">//删除 removeSub</span></span><br><span class="line">            <span class="keyword">this</span>$<span class="number">1.</span>deps[i].removeSub(<span class="keyword">this</span>$<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.active = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从Watcher类可以看到，每次实例化Watcher的时候都会调用this.get函数，<br>这里this.get()主要有两步骤</p>
<ol>
<li>调用pushTarget</li>
<li>调用getter方法触发Observer的get方法将自己加入订阅者</li>
</ol>
<p>那又是什么时候会实例化Watcher呢</p>
<ol>
<li>安装组件<code>mountComponent</code></li>
<li>初始化计算属性 并且判断属性的key是否在data中 ，将计算属性的key添加入监听者中<code>initComputed</code></li>
<li>Vue.prototype.$watch中<ol>
<li>keep-alive组件的mounted</li>
<li>封装在createWatcher函数中<ol>
<li>初始化watch监听<code>initWatch</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="watch-和-computed的区别"><a href="#watch-和-computed的区别" class="headerlink" title="watch 和 computed的区别"></a>watch 和 computed的区别</h1><h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><p>计算属性的初始化是发生在Vue实例初始化的initState里面然后调用initComputed</p>
<h3 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">        <span class="comment">//  如果computed 属性key 不在虚拟dom中</span></span><br><span class="line">        <span class="comment">//  定义计算属性 并且 把属性的数据 添加到对象监听中</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initComputed这段代码做了几件事</p>
<ol>
<li>获取这个 userDef 对应的 getter 函数(存放到 <code>watcher.getter</code> 中，用于后面的计算)</li>
<li>每个computed配发watcher；这个watcher属性很重要 <code>{ lazy: true }</code></li>
<li>defineComputed处理；</li>
<li>收集所有computed的watcher；</li>
</ol>
<p>在Watcher源码里lazy作用</p>
<ol>
<li>computed新建watcher的时候，传入lazy，作用是把计算结果缓存起来，而不是每次使用都要重新计算；</li>
<li>保存设置的 getter，把用户设置的 computed-getter，存放到 watcher.getter 中，用于后面的计算；</li>
<li>watcher.value 存放计算结果，但是这里有个条件，因为 lazy 的原因，不会新建实例并马上读取值；这里可以算是 Vue 的一个优化，只有你再读取 computed，再开始计算，而不是初始化就开始计算值了，虽然没有一开始计算，但是计算 value 还是这个 watcher.get 这个方法</li>
</ol>
<h3 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a>defineComputed</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params">target,key,userDef</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//userDef是function，getter设为userDef或userDef的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">//shouldCache是否缓存，这也是使用computed属性最重要的原因，computed值会被缓存起来，而不是每次重新执行函数生成</span></span><br><span class="line">        sharedPropertyDefinition.get = shouldCache</span><br><span class="line">          ? createComputedGetter(key)</span><br><span class="line">          : userDef;</span><br><span class="line">        sharedPropertyDefinition.set = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//userDef是不是function，getter设为userDef.get,setter设为userDef.set</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sharedPropertyDefinition.get = userDef.get</span><br><span class="line">          ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">            ? createComputedGetter(key)</span><br><span class="line">            : userDef.get</span><br><span class="line">          : <span class="literal">null</span>;</span><br><span class="line">        sharedPropertyDefinition.set = userDef.set</span><br><span class="line">          ? userDef.set</span><br><span class="line">          : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//，将computed属性代理到vm上，通过vm[key]访问computed属性值</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defineComputed</code> 方法实质也是利用 <code>Object.defineProperty</code> 给计算属性添加 set get。<br>set函数默认是空函数，如果用户设置，则使用用户设置</p>
<h3 id="createComputedGetter"><a href="#createComputedGetter" class="headerlink" title="createComputedGetter"></a>createComputedGetter</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      watcher.depend()</span><br><span class="line">      <span class="keyword">return</span> watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.depend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> i = <span class="keyword">this</span>.deps.length;    </span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;        </span><br><span class="line">        <span class="keyword">this</span>.deps[i].depend();</span><br><span class="line">        dep.addSub(Dep.target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>缓存控制是通过watcher.dirty控制的，watcher.evaluate用来重新计算，更新缓存值，并重置dirty为false,表示缓存已更新</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    cb.call(vm, watcher.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 <code>const watcher = new Watcher(vm, expOrFn, cb, options)</code> 实例化了一个 watcher，这里需要注意一点这是一个 <code>user watcher</code>，因为 <code>options.user = true</code>。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，并且如果我们设置了 immediate 为 true，则直接会执行回调函数 cb。最后返回了一个 unwatchFn 方法，它会调用 teardown 方法去移除这个 watcher。</p>
<p>所以本质上侦听属性也是基于 Watcher 实现的，它是一个 user watcher。其实 Watcher 支持了不同的类型。</p>
<h1 id="Vue双向绑定的问题"><a href="#Vue双向绑定的问题" class="headerlink" title="Vue双向绑定的问题"></a>Vue双向绑定的问题</h1><h2 id="监听对象问题"><a href="#监听对象问题" class="headerlink" title="监听对象问题"></a>监听对象问题</h2><ul>
<li>无法检测对象属性的增、删、改</li>
</ul>
<p>对象和数组都是js里的引用类型，在实际存储中，数据是存储在堆中的，利用存储在栈里的对象名或者数组名的指针进行索引，因此也存在在浅拷贝和深拷贝以及等号赋值时，到底是仅仅新建了一个指针指向了同一份数据，还是两个指针分别指向了两份完全一样的数据的问题</p>
<h2 id="监听数组-对象的问题"><a href="#监听数组-对象的问题" class="headerlink" title="监听数组/对象的问题"></a>监听数组/对象的问题</h2><ul>
<li>无法检测数组的新增</li>
<li>无法检测通过索引改变数组的操作。</li>
</ul>
<p>Vue2.0中响应式数据是通过Object.defineProperty实现，因此无法检测数组/对象的新增。<br>为什么不能检测通过索引改变数组的操作呢？？<br>实际上Object.defineProperty 可以监听到数组改变，但是Vue没有这么做，尤雨溪给出理由是性能问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(obj, key ,value) - 可实现增、改</span><br><span class="line">//  watch时添加deep：true深度监听，只能监听到属性值的变化，新增、删除属性无法监听</span><br><span class="line">this.$watch('key', this.data, &#123;</span><br><span class="line">  deep: <span class="literal">true</span></span><br><span class="line">  <span class="comment">// immediate: true // 是否第一次触发</span></span><br><span class="line"> &#125;);</span><br><span class="line">watch时直接监听某个key</span><br></pre></td></tr></table></figure>

<p>this.$set源码： Vue.$set = set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment">     * triggers change notification if the property doesn't</span></span><br><span class="line"><span class="comment">     * already exist.</span></span><br><span class="line"><span class="comment">     **在对象上设置属性。添加新属性和触发器更改通知，如果该属性不</span></span><br><span class="line"><span class="comment">     *  已经存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如果是数组  并且key是数字 就更新数组</span></span><br><span class="line">    <span class="comment">//如果是对象则重新赋值</span></span><br><span class="line">    <span class="comment">//如果 (target).__ob__ 存在则表明该数据以前添加过观察者对象中  //通知订阅者ob.value更新数据 添加观察者  define  set get 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//判断数据 是否是undefined或者null</span></span><br><span class="line">            (isUndef(target) || isPrimitive(target))   <span class="comment">//判断数据类型是否是string，number，symbol，boolean</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//必须是对象数组才可以 否则发出警告</span></span><br><span class="line">            warn((<span class="string">"Cannot set reactive property on undefined, null, or primitive value: "</span> + ((target))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是数组  并且key是数字</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">            <span class="comment">//设置数组的长度</span></span><br><span class="line">            target.length = <span class="built_in">Math</span>.max(target.length, key);</span><br><span class="line">            <span class="comment">//像数组尾部添加一个新数据，相当于push</span></span><br><span class="line">            target.splice(key, <span class="number">1</span>, val);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断key是否在target 上，并且不是在Object.prototype 原型上，而不是通过父层原型链查找的</span></span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">            target[key] = val;  <span class="comment">//赋值</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//声明一个对象ob 值为该target对象中的原型上面的所有方法和属性 ，表明该数据加入过观察者中</span></span><br><span class="line">        <span class="keyword">var</span> ob = (target).__ob__;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//vmCount 记录vue被实例化的次数</span></span><br><span class="line">        <span class="comment">//  _isVue 是不是vue</span></span><br><span class="line">        <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">            <span class="comment">//如果不是生产环境，发出警告</span></span><br><span class="line">            <span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">                <span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +</span><br><span class="line">                <span class="string">'at runtime - declare it upfront in the data option.'</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ob不存在 说明他没有添加观察者 则直接赋值</span></span><br><span class="line">        <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">            target[key] = val;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知订阅者ob.value更新数据 添加观察者  define  set get 方法</span></span><br><span class="line">        defineReactive(ob.value, key, val);</span><br><span class="line">        <span class="comment">//通知订阅者ob.value更新数据</span></span><br><span class="line">        ob.dep.notify();</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/vue/Vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.svg" alt="Vue源码结构" title="Vue源码结构"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://segmentfault.com/a/1190000014274840" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014274840</a><br><a href="https://juejin.im/post/6844903854740340749#heading-3" target="_blank" rel="noopener">https://juejin.im/post/6844903854740340749#heading-3</a><br><a href="https://www.cnblogs.com/youhong/p/12173354.html" target="_blank" rel="noopener">https://www.cnblogs.com/youhong/p/12173354.html</a><br><a href="https://juejin.im/post/6844904186669170701" target="_blank" rel="noopener">Vue源码分析</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>双向绑定</category>
      </categories>
      <tags>
        <tag>vue源码</tag>
        <tag>vue双向绑定</tag>
      </tags>
  </entry>
</search>
